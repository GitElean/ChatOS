// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mensaje.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_mensaje_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_mensaje_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_mensaje_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_mensaje_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[17]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_mensaje_2eproto;
namespace chat {
class BroadcastMessage;
class BroadcastMessageDefaultTypeInternal;
extern BroadcastMessageDefaultTypeInternal _BroadcastMessage_default_instance_;
class BroadcastRequest;
class BroadcastRequestDefaultTypeInternal;
extern BroadcastRequestDefaultTypeInternal _BroadcastRequest_default_instance_;
class BroadcastResponse;
class BroadcastResponseDefaultTypeInternal;
extern BroadcastResponseDefaultTypeInternal _BroadcastResponse_default_instance_;
class ChangeStatusRequest;
class ChangeStatusRequestDefaultTypeInternal;
extern ChangeStatusRequestDefaultTypeInternal _ChangeStatusRequest_default_instance_;
class ChangeStatusResponse;
class ChangeStatusResponseDefaultTypeInternal;
extern ChangeStatusResponseDefaultTypeInternal _ChangeStatusResponse_default_instance_;
class ClientPetition;
class ClientPetitionDefaultTypeInternal;
extern ClientPetitionDefaultTypeInternal _ClientPetition_default_instance_;
class ConnectedUser;
class ConnectedUserDefaultTypeInternal;
extern ConnectedUserDefaultTypeInternal _ConnectedUser_default_instance_;
class ConnectedUserResponse;
class ConnectedUserResponseDefaultTypeInternal;
extern ConnectedUserResponseDefaultTypeInternal _ConnectedUserResponse_default_instance_;
class DirectMessage;
class DirectMessageDefaultTypeInternal;
extern DirectMessageDefaultTypeInternal _DirectMessage_default_instance_;
class DirectMessageRequest;
class DirectMessageRequestDefaultTypeInternal;
extern DirectMessageRequestDefaultTypeInternal _DirectMessageRequest_default_instance_;
class DirectMessageResponse;
class DirectMessageResponseDefaultTypeInternal;
extern DirectMessageResponseDefaultTypeInternal _DirectMessageResponse_default_instance_;
class ErrorResponse;
class ErrorResponseDefaultTypeInternal;
extern ErrorResponseDefaultTypeInternal _ErrorResponse_default_instance_;
class MyInfoAcknowledge;
class MyInfoAcknowledgeDefaultTypeInternal;
extern MyInfoAcknowledgeDefaultTypeInternal _MyInfoAcknowledge_default_instance_;
class MyInfoResponse;
class MyInfoResponseDefaultTypeInternal;
extern MyInfoResponseDefaultTypeInternal _MyInfoResponse_default_instance_;
class MyInfoSynchronize;
class MyInfoSynchronizeDefaultTypeInternal;
extern MyInfoSynchronizeDefaultTypeInternal _MyInfoSynchronize_default_instance_;
class ServerResponse;
class ServerResponseDefaultTypeInternal;
extern ServerResponseDefaultTypeInternal _ServerResponse_default_instance_;
class connectedUserRequest;
class connectedUserRequestDefaultTypeInternal;
extern connectedUserRequestDefaultTypeInternal _connectedUserRequest_default_instance_;
}  // namespace chat
PROTOBUF_NAMESPACE_OPEN
template<> ::chat::BroadcastMessage* Arena::CreateMaybeMessage<::chat::BroadcastMessage>(Arena*);
template<> ::chat::BroadcastRequest* Arena::CreateMaybeMessage<::chat::BroadcastRequest>(Arena*);
template<> ::chat::BroadcastResponse* Arena::CreateMaybeMessage<::chat::BroadcastResponse>(Arena*);
template<> ::chat::ChangeStatusRequest* Arena::CreateMaybeMessage<::chat::ChangeStatusRequest>(Arena*);
template<> ::chat::ChangeStatusResponse* Arena::CreateMaybeMessage<::chat::ChangeStatusResponse>(Arena*);
template<> ::chat::ClientPetition* Arena::CreateMaybeMessage<::chat::ClientPetition>(Arena*);
template<> ::chat::ConnectedUser* Arena::CreateMaybeMessage<::chat::ConnectedUser>(Arena*);
template<> ::chat::ConnectedUserResponse* Arena::CreateMaybeMessage<::chat::ConnectedUserResponse>(Arena*);
template<> ::chat::DirectMessage* Arena::CreateMaybeMessage<::chat::DirectMessage>(Arena*);
template<> ::chat::DirectMessageRequest* Arena::CreateMaybeMessage<::chat::DirectMessageRequest>(Arena*);
template<> ::chat::DirectMessageResponse* Arena::CreateMaybeMessage<::chat::DirectMessageResponse>(Arena*);
template<> ::chat::ErrorResponse* Arena::CreateMaybeMessage<::chat::ErrorResponse>(Arena*);
template<> ::chat::MyInfoAcknowledge* Arena::CreateMaybeMessage<::chat::MyInfoAcknowledge>(Arena*);
template<> ::chat::MyInfoResponse* Arena::CreateMaybeMessage<::chat::MyInfoResponse>(Arena*);
template<> ::chat::MyInfoSynchronize* Arena::CreateMaybeMessage<::chat::MyInfoSynchronize>(Arena*);
template<> ::chat::ServerResponse* Arena::CreateMaybeMessage<::chat::ServerResponse>(Arena*);
template<> ::chat::connectedUserRequest* Arena::CreateMaybeMessage<::chat::connectedUserRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace chat {

// ===================================================================

class MyInfoSynchronize PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.MyInfoSynchronize) */ {
 public:
  inline MyInfoSynchronize() : MyInfoSynchronize(nullptr) {};
  virtual ~MyInfoSynchronize();

  MyInfoSynchronize(const MyInfoSynchronize& from);
  MyInfoSynchronize(MyInfoSynchronize&& from) noexcept
    : MyInfoSynchronize() {
    *this = ::std::move(from);
  }

  inline MyInfoSynchronize& operator=(const MyInfoSynchronize& from) {
    CopyFrom(from);
    return *this;
  }
  inline MyInfoSynchronize& operator=(MyInfoSynchronize&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MyInfoSynchronize& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MyInfoSynchronize* internal_default_instance() {
    return reinterpret_cast<const MyInfoSynchronize*>(
               &_MyInfoSynchronize_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MyInfoSynchronize& a, MyInfoSynchronize& b) {
    a.Swap(&b);
  }
  inline void Swap(MyInfoSynchronize* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MyInfoSynchronize* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MyInfoSynchronize* New() const final {
    return CreateMaybeMessage<MyInfoSynchronize>(nullptr);
  }

  MyInfoSynchronize* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MyInfoSynchronize>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MyInfoSynchronize& from);
  void MergeFrom(const MyInfoSynchronize& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MyInfoSynchronize* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.MyInfoSynchronize";
  }
  protected:
  explicit MyInfoSynchronize(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mensaje_2eproto);
    return ::descriptor_table_mensaje_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kIpFieldNumber = 2,
  };
  // required string username = 1;
  bool has_username() const;
  private:
  bool _internal_has_username() const;
  public:
  void clear_username();
  const std::string& username() const;
  void set_username(const std::string& value);
  void set_username(std::string&& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  std::string* mutable_username();
  std::string* release_username();
  void set_allocated_username(std::string* username);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_username();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_username(
      std::string* username);
  private:
  const std::string& _internal_username() const;
  void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // optional string ip = 2;
  bool has_ip() const;
  private:
  bool _internal_has_ip() const;
  public:
  void clear_ip();
  const std::string& ip() const;
  void set_ip(const std::string& value);
  void set_ip(std::string&& value);
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  std::string* mutable_ip();
  std::string* release_ip();
  void set_allocated_ip(std::string* ip);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_ip();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_ip(
      std::string* ip);
  private:
  const std::string& _internal_ip() const;
  void _internal_set_ip(const std::string& value);
  std::string* _internal_mutable_ip();
  public:

  // @@protoc_insertion_point(class_scope:chat.MyInfoSynchronize)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
  friend struct ::TableStruct_mensaje_2eproto;
};
// -------------------------------------------------------------------

class MyInfoResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.MyInfoResponse) */ {
 public:
  inline MyInfoResponse() : MyInfoResponse(nullptr) {};
  virtual ~MyInfoResponse();

  MyInfoResponse(const MyInfoResponse& from);
  MyInfoResponse(MyInfoResponse&& from) noexcept
    : MyInfoResponse() {
    *this = ::std::move(from);
  }

  inline MyInfoResponse& operator=(const MyInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MyInfoResponse& operator=(MyInfoResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MyInfoResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MyInfoResponse* internal_default_instance() {
    return reinterpret_cast<const MyInfoResponse*>(
               &_MyInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(MyInfoResponse& a, MyInfoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MyInfoResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MyInfoResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MyInfoResponse* New() const final {
    return CreateMaybeMessage<MyInfoResponse>(nullptr);
  }

  MyInfoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MyInfoResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MyInfoResponse& from);
  void MergeFrom(const MyInfoResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MyInfoResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.MyInfoResponse";
  }
  protected:
  explicit MyInfoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mensaje_2eproto);
    return ::descriptor_table_mensaje_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
  };
  // required int32 userId = 1;
  bool has_userid() const;
  private:
  bool _internal_has_userid() const;
  public:
  void clear_userid();
  ::PROTOBUF_NAMESPACE_ID::int32 userid() const;
  void set_userid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_userid() const;
  void _internal_set_userid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:chat.MyInfoResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 userid_;
  friend struct ::TableStruct_mensaje_2eproto;
};
// -------------------------------------------------------------------

class MyInfoAcknowledge PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.MyInfoAcknowledge) */ {
 public:
  inline MyInfoAcknowledge() : MyInfoAcknowledge(nullptr) {};
  virtual ~MyInfoAcknowledge();

  MyInfoAcknowledge(const MyInfoAcknowledge& from);
  MyInfoAcknowledge(MyInfoAcknowledge&& from) noexcept
    : MyInfoAcknowledge() {
    *this = ::std::move(from);
  }

  inline MyInfoAcknowledge& operator=(const MyInfoAcknowledge& from) {
    CopyFrom(from);
    return *this;
  }
  inline MyInfoAcknowledge& operator=(MyInfoAcknowledge&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MyInfoAcknowledge& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MyInfoAcknowledge* internal_default_instance() {
    return reinterpret_cast<const MyInfoAcknowledge*>(
               &_MyInfoAcknowledge_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(MyInfoAcknowledge& a, MyInfoAcknowledge& b) {
    a.Swap(&b);
  }
  inline void Swap(MyInfoAcknowledge* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MyInfoAcknowledge* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MyInfoAcknowledge* New() const final {
    return CreateMaybeMessage<MyInfoAcknowledge>(nullptr);
  }

  MyInfoAcknowledge* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MyInfoAcknowledge>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MyInfoAcknowledge& from);
  void MergeFrom(const MyInfoAcknowledge& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MyInfoAcknowledge* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.MyInfoAcknowledge";
  }
  protected:
  explicit MyInfoAcknowledge(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mensaje_2eproto);
    return ::descriptor_table_mensaje_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
  };
  // required int32 userId = 1;
  bool has_userid() const;
  private:
  bool _internal_has_userid() const;
  public:
  void clear_userid();
  ::PROTOBUF_NAMESPACE_ID::int32 userid() const;
  void set_userid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_userid() const;
  void _internal_set_userid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:chat.MyInfoAcknowledge)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 userid_;
  friend struct ::TableStruct_mensaje_2eproto;
};
// -------------------------------------------------------------------

class connectedUserRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.connectedUserRequest) */ {
 public:
  inline connectedUserRequest() : connectedUserRequest(nullptr) {};
  virtual ~connectedUserRequest();

  connectedUserRequest(const connectedUserRequest& from);
  connectedUserRequest(connectedUserRequest&& from) noexcept
    : connectedUserRequest() {
    *this = ::std::move(from);
  }

  inline connectedUserRequest& operator=(const connectedUserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline connectedUserRequest& operator=(connectedUserRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const connectedUserRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const connectedUserRequest* internal_default_instance() {
    return reinterpret_cast<const connectedUserRequest*>(
               &_connectedUserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(connectedUserRequest& a, connectedUserRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(connectedUserRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(connectedUserRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline connectedUserRequest* New() const final {
    return CreateMaybeMessage<connectedUserRequest>(nullptr);
  }

  connectedUserRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<connectedUserRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const connectedUserRequest& from);
  void MergeFrom(const connectedUserRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(connectedUserRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.connectedUserRequest";
  }
  protected:
  explicit connectedUserRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mensaje_2eproto);
    return ::descriptor_table_mensaje_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 2,
    kUserIdFieldNumber = 1,
  };
  // optional string username = 2;
  bool has_username() const;
  private:
  bool _internal_has_username() const;
  public:
  void clear_username();
  const std::string& username() const;
  void set_username(const std::string& value);
  void set_username(std::string&& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  std::string* mutable_username();
  std::string* release_username();
  void set_allocated_username(std::string* username);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_username();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_username(
      std::string* username);
  private:
  const std::string& _internal_username() const;
  void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // optional int32 userId = 1;
  bool has_userid() const;
  private:
  bool _internal_has_userid() const;
  public:
  void clear_userid();
  ::PROTOBUF_NAMESPACE_ID::int32 userid() const;
  void set_userid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_userid() const;
  void _internal_set_userid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:chat.connectedUserRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::int32 userid_;
  friend struct ::TableStruct_mensaje_2eproto;
};
// -------------------------------------------------------------------

class ConnectedUser PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.ConnectedUser) */ {
 public:
  inline ConnectedUser() : ConnectedUser(nullptr) {};
  virtual ~ConnectedUser();

  ConnectedUser(const ConnectedUser& from);
  ConnectedUser(ConnectedUser&& from) noexcept
    : ConnectedUser() {
    *this = ::std::move(from);
  }

  inline ConnectedUser& operator=(const ConnectedUser& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectedUser& operator=(ConnectedUser&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ConnectedUser& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConnectedUser* internal_default_instance() {
    return reinterpret_cast<const ConnectedUser*>(
               &_ConnectedUser_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ConnectedUser& a, ConnectedUser& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectedUser* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectedUser* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ConnectedUser* New() const final {
    return CreateMaybeMessage<ConnectedUser>(nullptr);
  }

  ConnectedUser* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ConnectedUser>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ConnectedUser& from);
  void MergeFrom(const ConnectedUser& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectedUser* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.ConnectedUser";
  }
  protected:
  explicit ConnectedUser(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mensaje_2eproto);
    return ::descriptor_table_mensaje_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kStatusFieldNumber = 2,
    kIpFieldNumber = 4,
    kUserIdFieldNumber = 3,
  };
  // required string username = 1;
  bool has_username() const;
  private:
  bool _internal_has_username() const;
  public:
  void clear_username();
  const std::string& username() const;
  void set_username(const std::string& value);
  void set_username(std::string&& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  std::string* mutable_username();
  std::string* release_username();
  void set_allocated_username(std::string* username);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_username();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_username(
      std::string* username);
  private:
  const std::string& _internal_username() const;
  void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // optional string status = 2;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const std::string& status() const;
  void set_status(const std::string& value);
  void set_status(std::string&& value);
  void set_status(const char* value);
  void set_status(const char* value, size_t size);
  std::string* mutable_status();
  std::string* release_status();
  void set_allocated_status(std::string* status);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_status();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_status(
      std::string* status);
  private:
  const std::string& _internal_status() const;
  void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // optional string ip = 4;
  bool has_ip() const;
  private:
  bool _internal_has_ip() const;
  public:
  void clear_ip();
  const std::string& ip() const;
  void set_ip(const std::string& value);
  void set_ip(std::string&& value);
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  std::string* mutable_ip();
  std::string* release_ip();
  void set_allocated_ip(std::string* ip);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_ip();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_ip(
      std::string* ip);
  private:
  const std::string& _internal_ip() const;
  void _internal_set_ip(const std::string& value);
  std::string* _internal_mutable_ip();
  public:

  // optional int32 userId = 3;
  bool has_userid() const;
  private:
  bool _internal_has_userid() const;
  public:
  void clear_userid();
  ::PROTOBUF_NAMESPACE_ID::int32 userid() const;
  void set_userid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_userid() const;
  void _internal_set_userid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:chat.ConnectedUser)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
  ::PROTOBUF_NAMESPACE_ID::int32 userid_;
  friend struct ::TableStruct_mensaje_2eproto;
};
// -------------------------------------------------------------------

class ConnectedUserResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.ConnectedUserResponse) */ {
 public:
  inline ConnectedUserResponse() : ConnectedUserResponse(nullptr) {};
  virtual ~ConnectedUserResponse();

  ConnectedUserResponse(const ConnectedUserResponse& from);
  ConnectedUserResponse(ConnectedUserResponse&& from) noexcept
    : ConnectedUserResponse() {
    *this = ::std::move(from);
  }

  inline ConnectedUserResponse& operator=(const ConnectedUserResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectedUserResponse& operator=(ConnectedUserResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ConnectedUserResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConnectedUserResponse* internal_default_instance() {
    return reinterpret_cast<const ConnectedUserResponse*>(
               &_ConnectedUserResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ConnectedUserResponse& a, ConnectedUserResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ConnectedUserResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectedUserResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ConnectedUserResponse* New() const final {
    return CreateMaybeMessage<ConnectedUserResponse>(nullptr);
  }

  ConnectedUserResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ConnectedUserResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ConnectedUserResponse& from);
  void MergeFrom(const ConnectedUserResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConnectedUserResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.ConnectedUserResponse";
  }
  protected:
  explicit ConnectedUserResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mensaje_2eproto);
    return ::descriptor_table_mensaje_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConnectedUsersFieldNumber = 1,
  };
  // repeated .chat.ConnectedUser connectedUsers = 1;
  int connectedusers_size() const;
  private:
  int _internal_connectedusers_size() const;
  public:
  void clear_connectedusers();
  ::chat::ConnectedUser* mutable_connectedusers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chat::ConnectedUser >*
      mutable_connectedusers();
  private:
  const ::chat::ConnectedUser& _internal_connectedusers(int index) const;
  ::chat::ConnectedUser* _internal_add_connectedusers();
  public:
  const ::chat::ConnectedUser& connectedusers(int index) const;
  ::chat::ConnectedUser* add_connectedusers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chat::ConnectedUser >&
      connectedusers() const;

  // @@protoc_insertion_point(class_scope:chat.ConnectedUserResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chat::ConnectedUser > connectedusers_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mensaje_2eproto;
};
// -------------------------------------------------------------------

class ChangeStatusRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.ChangeStatusRequest) */ {
 public:
  inline ChangeStatusRequest() : ChangeStatusRequest(nullptr) {};
  virtual ~ChangeStatusRequest();

  ChangeStatusRequest(const ChangeStatusRequest& from);
  ChangeStatusRequest(ChangeStatusRequest&& from) noexcept
    : ChangeStatusRequest() {
    *this = ::std::move(from);
  }

  inline ChangeStatusRequest& operator=(const ChangeStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeStatusRequest& operator=(ChangeStatusRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ChangeStatusRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChangeStatusRequest* internal_default_instance() {
    return reinterpret_cast<const ChangeStatusRequest*>(
               &_ChangeStatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ChangeStatusRequest& a, ChangeStatusRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangeStatusRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangeStatusRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChangeStatusRequest* New() const final {
    return CreateMaybeMessage<ChangeStatusRequest>(nullptr);
  }

  ChangeStatusRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChangeStatusRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ChangeStatusRequest& from);
  void MergeFrom(const ChangeStatusRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeStatusRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.ChangeStatusRequest";
  }
  protected:
  explicit ChangeStatusRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mensaje_2eproto);
    return ::descriptor_table_mensaje_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // required string status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const std::string& status() const;
  void set_status(const std::string& value);
  void set_status(std::string&& value);
  void set_status(const char* value);
  void set_status(const char* value, size_t size);
  std::string* mutable_status();
  std::string* release_status();
  void set_allocated_status(std::string* status);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_status();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_status(
      std::string* status);
  private:
  const std::string& _internal_status() const;
  void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // @@protoc_insertion_point(class_scope:chat.ChangeStatusRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  friend struct ::TableStruct_mensaje_2eproto;
};
// -------------------------------------------------------------------

class ChangeStatusResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.ChangeStatusResponse) */ {
 public:
  inline ChangeStatusResponse() : ChangeStatusResponse(nullptr) {};
  virtual ~ChangeStatusResponse();

  ChangeStatusResponse(const ChangeStatusResponse& from);
  ChangeStatusResponse(ChangeStatusResponse&& from) noexcept
    : ChangeStatusResponse() {
    *this = ::std::move(from);
  }

  inline ChangeStatusResponse& operator=(const ChangeStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeStatusResponse& operator=(ChangeStatusResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ChangeStatusResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChangeStatusResponse* internal_default_instance() {
    return reinterpret_cast<const ChangeStatusResponse*>(
               &_ChangeStatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ChangeStatusResponse& a, ChangeStatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangeStatusResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangeStatusResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChangeStatusResponse* New() const final {
    return CreateMaybeMessage<ChangeStatusResponse>(nullptr);
  }

  ChangeStatusResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChangeStatusResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ChangeStatusResponse& from);
  void MergeFrom(const ChangeStatusResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeStatusResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.ChangeStatusResponse";
  }
  protected:
  explicit ChangeStatusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mensaje_2eproto);
    return ::descriptor_table_mensaje_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kUserIdFieldNumber = 1,
  };
  // required string status = 2;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const std::string& status() const;
  void set_status(const std::string& value);
  void set_status(std::string&& value);
  void set_status(const char* value);
  void set_status(const char* value, size_t size);
  std::string* mutable_status();
  std::string* release_status();
  void set_allocated_status(std::string* status);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_status();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_status(
      std::string* status);
  private:
  const std::string& _internal_status() const;
  void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // required int32 userId = 1;
  bool has_userid() const;
  private:
  bool _internal_has_userid() const;
  public:
  void clear_userid();
  ::PROTOBUF_NAMESPACE_ID::int32 userid() const;
  void set_userid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_userid() const;
  void _internal_set_userid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:chat.ChangeStatusResponse)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::PROTOBUF_NAMESPACE_ID::int32 userid_;
  friend struct ::TableStruct_mensaje_2eproto;
};
// -------------------------------------------------------------------

class BroadcastRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.BroadcastRequest) */ {
 public:
  inline BroadcastRequest() : BroadcastRequest(nullptr) {};
  virtual ~BroadcastRequest();

  BroadcastRequest(const BroadcastRequest& from);
  BroadcastRequest(BroadcastRequest&& from) noexcept
    : BroadcastRequest() {
    *this = ::std::move(from);
  }

  inline BroadcastRequest& operator=(const BroadcastRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BroadcastRequest& operator=(BroadcastRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BroadcastRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BroadcastRequest* internal_default_instance() {
    return reinterpret_cast<const BroadcastRequest*>(
               &_BroadcastRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(BroadcastRequest& a, BroadcastRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BroadcastRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BroadcastRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BroadcastRequest* New() const final {
    return CreateMaybeMessage<BroadcastRequest>(nullptr);
  }

  BroadcastRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BroadcastRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BroadcastRequest& from);
  void MergeFrom(const BroadcastRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BroadcastRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.BroadcastRequest";
  }
  protected:
  explicit BroadcastRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mensaje_2eproto);
    return ::descriptor_table_mensaje_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // required string message = 1;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_message();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_message(
      std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:chat.BroadcastRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  friend struct ::TableStruct_mensaje_2eproto;
};
// -------------------------------------------------------------------

class BroadcastResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.BroadcastResponse) */ {
 public:
  inline BroadcastResponse() : BroadcastResponse(nullptr) {};
  virtual ~BroadcastResponse();

  BroadcastResponse(const BroadcastResponse& from);
  BroadcastResponse(BroadcastResponse&& from) noexcept
    : BroadcastResponse() {
    *this = ::std::move(from);
  }

  inline BroadcastResponse& operator=(const BroadcastResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BroadcastResponse& operator=(BroadcastResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BroadcastResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BroadcastResponse* internal_default_instance() {
    return reinterpret_cast<const BroadcastResponse*>(
               &_BroadcastResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(BroadcastResponse& a, BroadcastResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BroadcastResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BroadcastResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BroadcastResponse* New() const final {
    return CreateMaybeMessage<BroadcastResponse>(nullptr);
  }

  BroadcastResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BroadcastResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BroadcastResponse& from);
  void MergeFrom(const BroadcastResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BroadcastResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.BroadcastResponse";
  }
  protected:
  explicit BroadcastResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mensaje_2eproto);
    return ::descriptor_table_mensaje_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageStatusFieldNumber = 1,
  };
  // required string messageStatus = 1;
  bool has_messagestatus() const;
  private:
  bool _internal_has_messagestatus() const;
  public:
  void clear_messagestatus();
  const std::string& messagestatus() const;
  void set_messagestatus(const std::string& value);
  void set_messagestatus(std::string&& value);
  void set_messagestatus(const char* value);
  void set_messagestatus(const char* value, size_t size);
  std::string* mutable_messagestatus();
  std::string* release_messagestatus();
  void set_allocated_messagestatus(std::string* messagestatus);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_messagestatus();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_messagestatus(
      std::string* messagestatus);
  private:
  const std::string& _internal_messagestatus() const;
  void _internal_set_messagestatus(const std::string& value);
  std::string* _internal_mutable_messagestatus();
  public:

  // @@protoc_insertion_point(class_scope:chat.BroadcastResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr messagestatus_;
  friend struct ::TableStruct_mensaje_2eproto;
};
// -------------------------------------------------------------------

class BroadcastMessage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.BroadcastMessage) */ {
 public:
  inline BroadcastMessage() : BroadcastMessage(nullptr) {};
  virtual ~BroadcastMessage();

  BroadcastMessage(const BroadcastMessage& from);
  BroadcastMessage(BroadcastMessage&& from) noexcept
    : BroadcastMessage() {
    *this = ::std::move(from);
  }

  inline BroadcastMessage& operator=(const BroadcastMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline BroadcastMessage& operator=(BroadcastMessage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BroadcastMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BroadcastMessage* internal_default_instance() {
    return reinterpret_cast<const BroadcastMessage*>(
               &_BroadcastMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(BroadcastMessage& a, BroadcastMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(BroadcastMessage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BroadcastMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BroadcastMessage* New() const final {
    return CreateMaybeMessage<BroadcastMessage>(nullptr);
  }

  BroadcastMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BroadcastMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BroadcastMessage& from);
  void MergeFrom(const BroadcastMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BroadcastMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.BroadcastMessage";
  }
  protected:
  explicit BroadcastMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mensaje_2eproto);
    return ::descriptor_table_mensaje_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
    kUsernameFieldNumber = 3,
    kUserIdFieldNumber = 2,
  };
  // required string message = 1;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_message();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_message(
      std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // optional string username = 3;
  bool has_username() const;
  private:
  bool _internal_has_username() const;
  public:
  void clear_username();
  const std::string& username() const;
  void set_username(const std::string& value);
  void set_username(std::string&& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  std::string* mutable_username();
  std::string* release_username();
  void set_allocated_username(std::string* username);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_username();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_username(
      std::string* username);
  private:
  const std::string& _internal_username() const;
  void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // required int32 userId = 2;
  bool has_userid() const;
  private:
  bool _internal_has_userid() const;
  public:
  void clear_userid();
  ::PROTOBUF_NAMESPACE_ID::int32 userid() const;
  void set_userid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_userid() const;
  void _internal_set_userid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:chat.BroadcastMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::int32 userid_;
  friend struct ::TableStruct_mensaje_2eproto;
};
// -------------------------------------------------------------------

class DirectMessageRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.DirectMessageRequest) */ {
 public:
  inline DirectMessageRequest() : DirectMessageRequest(nullptr) {};
  virtual ~DirectMessageRequest();

  DirectMessageRequest(const DirectMessageRequest& from);
  DirectMessageRequest(DirectMessageRequest&& from) noexcept
    : DirectMessageRequest() {
    *this = ::std::move(from);
  }

  inline DirectMessageRequest& operator=(const DirectMessageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DirectMessageRequest& operator=(DirectMessageRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DirectMessageRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DirectMessageRequest* internal_default_instance() {
    return reinterpret_cast<const DirectMessageRequest*>(
               &_DirectMessageRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(DirectMessageRequest& a, DirectMessageRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DirectMessageRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DirectMessageRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DirectMessageRequest* New() const final {
    return CreateMaybeMessage<DirectMessageRequest>(nullptr);
  }

  DirectMessageRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DirectMessageRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DirectMessageRequest& from);
  void MergeFrom(const DirectMessageRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DirectMessageRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.DirectMessageRequest";
  }
  protected:
  explicit DirectMessageRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mensaje_2eproto);
    return ::descriptor_table_mensaje_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
    kUsernameFieldNumber = 3,
    kUserIdFieldNumber = 2,
  };
  // required string message = 1;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_message();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_message(
      std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // optional string username = 3;
  bool has_username() const;
  private:
  bool _internal_has_username() const;
  public:
  void clear_username();
  const std::string& username() const;
  void set_username(const std::string& value);
  void set_username(std::string&& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  std::string* mutable_username();
  std::string* release_username();
  void set_allocated_username(std::string* username);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_username();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_username(
      std::string* username);
  private:
  const std::string& _internal_username() const;
  void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // optional int32 userId = 2;
  bool has_userid() const;
  private:
  bool _internal_has_userid() const;
  public:
  void clear_userid();
  ::PROTOBUF_NAMESPACE_ID::int32 userid() const;
  void set_userid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_userid() const;
  void _internal_set_userid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:chat.DirectMessageRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::int32 userid_;
  friend struct ::TableStruct_mensaje_2eproto;
};
// -------------------------------------------------------------------

class DirectMessageResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.DirectMessageResponse) */ {
 public:
  inline DirectMessageResponse() : DirectMessageResponse(nullptr) {};
  virtual ~DirectMessageResponse();

  DirectMessageResponse(const DirectMessageResponse& from);
  DirectMessageResponse(DirectMessageResponse&& from) noexcept
    : DirectMessageResponse() {
    *this = ::std::move(from);
  }

  inline DirectMessageResponse& operator=(const DirectMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DirectMessageResponse& operator=(DirectMessageResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DirectMessageResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DirectMessageResponse* internal_default_instance() {
    return reinterpret_cast<const DirectMessageResponse*>(
               &_DirectMessageResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(DirectMessageResponse& a, DirectMessageResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DirectMessageResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DirectMessageResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DirectMessageResponse* New() const final {
    return CreateMaybeMessage<DirectMessageResponse>(nullptr);
  }

  DirectMessageResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DirectMessageResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DirectMessageResponse& from);
  void MergeFrom(const DirectMessageResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DirectMessageResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.DirectMessageResponse";
  }
  protected:
  explicit DirectMessageResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mensaje_2eproto);
    return ::descriptor_table_mensaje_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageStatusFieldNumber = 1,
  };
  // required string messageStatus = 1;
  bool has_messagestatus() const;
  private:
  bool _internal_has_messagestatus() const;
  public:
  void clear_messagestatus();
  const std::string& messagestatus() const;
  void set_messagestatus(const std::string& value);
  void set_messagestatus(std::string&& value);
  void set_messagestatus(const char* value);
  void set_messagestatus(const char* value, size_t size);
  std::string* mutable_messagestatus();
  std::string* release_messagestatus();
  void set_allocated_messagestatus(std::string* messagestatus);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_messagestatus();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_messagestatus(
      std::string* messagestatus);
  private:
  const std::string& _internal_messagestatus() const;
  void _internal_set_messagestatus(const std::string& value);
  std::string* _internal_mutable_messagestatus();
  public:

  // @@protoc_insertion_point(class_scope:chat.DirectMessageResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr messagestatus_;
  friend struct ::TableStruct_mensaje_2eproto;
};
// -------------------------------------------------------------------

class DirectMessage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.DirectMessage) */ {
 public:
  inline DirectMessage() : DirectMessage(nullptr) {};
  virtual ~DirectMessage();

  DirectMessage(const DirectMessage& from);
  DirectMessage(DirectMessage&& from) noexcept
    : DirectMessage() {
    *this = ::std::move(from);
  }

  inline DirectMessage& operator=(const DirectMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline DirectMessage& operator=(DirectMessage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DirectMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DirectMessage* internal_default_instance() {
    return reinterpret_cast<const DirectMessage*>(
               &_DirectMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(DirectMessage& a, DirectMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(DirectMessage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DirectMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DirectMessage* New() const final {
    return CreateMaybeMessage<DirectMessage>(nullptr);
  }

  DirectMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DirectMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DirectMessage& from);
  void MergeFrom(const DirectMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DirectMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.DirectMessage";
  }
  protected:
  explicit DirectMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mensaje_2eproto);
    return ::descriptor_table_mensaje_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
    kUsernameFieldNumber = 3,
    kUserIdFieldNumber = 2,
  };
  // required string message = 1;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_message();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_message(
      std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // optional string username = 3;
  bool has_username() const;
  private:
  bool _internal_has_username() const;
  public:
  void clear_username();
  const std::string& username() const;
  void set_username(const std::string& value);
  void set_username(std::string&& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  std::string* mutable_username();
  std::string* release_username();
  void set_allocated_username(std::string* username);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_username();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_username(
      std::string* username);
  private:
  const std::string& _internal_username() const;
  void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // required int32 userId = 2;
  bool has_userid() const;
  private:
  bool _internal_has_userid() const;
  public:
  void clear_userid();
  ::PROTOBUF_NAMESPACE_ID::int32 userid() const;
  void set_userid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_userid() const;
  void _internal_set_userid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:chat.DirectMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::int32 userid_;
  friend struct ::TableStruct_mensaje_2eproto;
};
// -------------------------------------------------------------------

class ErrorResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.ErrorResponse) */ {
 public:
  inline ErrorResponse() : ErrorResponse(nullptr) {};
  virtual ~ErrorResponse();

  ErrorResponse(const ErrorResponse& from);
  ErrorResponse(ErrorResponse&& from) noexcept
    : ErrorResponse() {
    *this = ::std::move(from);
  }

  inline ErrorResponse& operator=(const ErrorResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ErrorResponse& operator=(ErrorResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ErrorResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ErrorResponse* internal_default_instance() {
    return reinterpret_cast<const ErrorResponse*>(
               &_ErrorResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ErrorResponse& a, ErrorResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ErrorResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ErrorResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ErrorResponse* New() const final {
    return CreateMaybeMessage<ErrorResponse>(nullptr);
  }

  ErrorResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ErrorResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ErrorResponse& from);
  void MergeFrom(const ErrorResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ErrorResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.ErrorResponse";
  }
  protected:
  explicit ErrorResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mensaje_2eproto);
    return ::descriptor_table_mensaje_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 1,
  };
  // required string errorMessage = 1;
  bool has_errormessage() const;
  private:
  bool _internal_has_errormessage() const;
  public:
  void clear_errormessage();
  const std::string& errormessage() const;
  void set_errormessage(const std::string& value);
  void set_errormessage(std::string&& value);
  void set_errormessage(const char* value);
  void set_errormessage(const char* value, size_t size);
  std::string* mutable_errormessage();
  std::string* release_errormessage();
  void set_allocated_errormessage(std::string* errormessage);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_errormessage();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_errormessage(
      std::string* errormessage);
  private:
  const std::string& _internal_errormessage() const;
  void _internal_set_errormessage(const std::string& value);
  std::string* _internal_mutable_errormessage();
  public:

  // @@protoc_insertion_point(class_scope:chat.ErrorResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errormessage_;
  friend struct ::TableStruct_mensaje_2eproto;
};
// -------------------------------------------------------------------

class ClientPetition PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.ClientPetition) */ {
 public:
  inline ClientPetition() : ClientPetition(nullptr) {};
  virtual ~ClientPetition();

  ClientPetition(const ClientPetition& from);
  ClientPetition(ClientPetition&& from) noexcept
    : ClientPetition() {
    *this = ::std::move(from);
  }

  inline ClientPetition& operator=(const ClientPetition& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientPetition& operator=(ClientPetition&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ClientPetition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientPetition* internal_default_instance() {
    return reinterpret_cast<const ClientPetition*>(
               &_ClientPetition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ClientPetition& a, ClientPetition& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientPetition* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientPetition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClientPetition* New() const final {
    return CreateMaybeMessage<ClientPetition>(nullptr);
  }

  ClientPetition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClientPetition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClientPetition& from);
  void MergeFrom(const ClientPetition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientPetition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.ClientPetition";
  }
  protected:
  explicit ClientPetition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mensaje_2eproto);
    return ::descriptor_table_mensaje_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSynchronizeFieldNumber = 3,
    kConnectedUsersFieldNumber = 4,
    kChangeStatusFieldNumber = 5,
    kBroadcastFieldNumber = 6,
    kDirectMessageFieldNumber = 7,
    kAcknowledgeFieldNumber = 8,
    kOptionFieldNumber = 1,
    kUserIdFieldNumber = 2,
  };
  // optional .chat.MyInfoSynchronize synchronize = 3;
  bool has_synchronize() const;
  private:
  bool _internal_has_synchronize() const;
  public:
  void clear_synchronize();
  const ::chat::MyInfoSynchronize& synchronize() const;
  ::chat::MyInfoSynchronize* release_synchronize();
  ::chat::MyInfoSynchronize* mutable_synchronize();
  void set_allocated_synchronize(::chat::MyInfoSynchronize* synchronize);
  private:
  const ::chat::MyInfoSynchronize& _internal_synchronize() const;
  ::chat::MyInfoSynchronize* _internal_mutable_synchronize();
  public:
  void unsafe_arena_set_allocated_synchronize(
      ::chat::MyInfoSynchronize* synchronize);
  ::chat::MyInfoSynchronize* unsafe_arena_release_synchronize();

  // optional .chat.connectedUserRequest connectedUsers = 4;
  bool has_connectedusers() const;
  private:
  bool _internal_has_connectedusers() const;
  public:
  void clear_connectedusers();
  const ::chat::connectedUserRequest& connectedusers() const;
  ::chat::connectedUserRequest* release_connectedusers();
  ::chat::connectedUserRequest* mutable_connectedusers();
  void set_allocated_connectedusers(::chat::connectedUserRequest* connectedusers);
  private:
  const ::chat::connectedUserRequest& _internal_connectedusers() const;
  ::chat::connectedUserRequest* _internal_mutable_connectedusers();
  public:
  void unsafe_arena_set_allocated_connectedusers(
      ::chat::connectedUserRequest* connectedusers);
  ::chat::connectedUserRequest* unsafe_arena_release_connectedusers();

  // optional .chat.ChangeStatusRequest changeStatus = 5;
  bool has_changestatus() const;
  private:
  bool _internal_has_changestatus() const;
  public:
  void clear_changestatus();
  const ::chat::ChangeStatusRequest& changestatus() const;
  ::chat::ChangeStatusRequest* release_changestatus();
  ::chat::ChangeStatusRequest* mutable_changestatus();
  void set_allocated_changestatus(::chat::ChangeStatusRequest* changestatus);
  private:
  const ::chat::ChangeStatusRequest& _internal_changestatus() const;
  ::chat::ChangeStatusRequest* _internal_mutable_changestatus();
  public:
  void unsafe_arena_set_allocated_changestatus(
      ::chat::ChangeStatusRequest* changestatus);
  ::chat::ChangeStatusRequest* unsafe_arena_release_changestatus();

  // optional .chat.BroadcastRequest broadcast = 6;
  bool has_broadcast() const;
  private:
  bool _internal_has_broadcast() const;
  public:
  void clear_broadcast();
  const ::chat::BroadcastRequest& broadcast() const;
  ::chat::BroadcastRequest* release_broadcast();
  ::chat::BroadcastRequest* mutable_broadcast();
  void set_allocated_broadcast(::chat::BroadcastRequest* broadcast);
  private:
  const ::chat::BroadcastRequest& _internal_broadcast() const;
  ::chat::BroadcastRequest* _internal_mutable_broadcast();
  public:
  void unsafe_arena_set_allocated_broadcast(
      ::chat::BroadcastRequest* broadcast);
  ::chat::BroadcastRequest* unsafe_arena_release_broadcast();

  // optional .chat.DirectMessageRequest directMessage = 7;
  bool has_directmessage() const;
  private:
  bool _internal_has_directmessage() const;
  public:
  void clear_directmessage();
  const ::chat::DirectMessageRequest& directmessage() const;
  ::chat::DirectMessageRequest* release_directmessage();
  ::chat::DirectMessageRequest* mutable_directmessage();
  void set_allocated_directmessage(::chat::DirectMessageRequest* directmessage);
  private:
  const ::chat::DirectMessageRequest& _internal_directmessage() const;
  ::chat::DirectMessageRequest* _internal_mutable_directmessage();
  public:
  void unsafe_arena_set_allocated_directmessage(
      ::chat::DirectMessageRequest* directmessage);
  ::chat::DirectMessageRequest* unsafe_arena_release_directmessage();

  // optional .chat.MyInfoAcknowledge acknowledge = 8;
  bool has_acknowledge() const;
  private:
  bool _internal_has_acknowledge() const;
  public:
  void clear_acknowledge();
  const ::chat::MyInfoAcknowledge& acknowledge() const;
  ::chat::MyInfoAcknowledge* release_acknowledge();
  ::chat::MyInfoAcknowledge* mutable_acknowledge();
  void set_allocated_acknowledge(::chat::MyInfoAcknowledge* acknowledge);
  private:
  const ::chat::MyInfoAcknowledge& _internal_acknowledge() const;
  ::chat::MyInfoAcknowledge* _internal_mutable_acknowledge();
  public:
  void unsafe_arena_set_allocated_acknowledge(
      ::chat::MyInfoAcknowledge* acknowledge);
  ::chat::MyInfoAcknowledge* unsafe_arena_release_acknowledge();

  // required int32 option = 1;
  bool has_option() const;
  private:
  bool _internal_has_option() const;
  public:
  void clear_option();
  ::PROTOBUF_NAMESPACE_ID::int32 option() const;
  void set_option(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_option() const;
  void _internal_set_option(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 userId = 2;
  bool has_userid() const;
  private:
  bool _internal_has_userid() const;
  public:
  void clear_userid();
  ::PROTOBUF_NAMESPACE_ID::int32 userid() const;
  void set_userid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_userid() const;
  void _internal_set_userid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:chat.ClientPetition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::chat::MyInfoSynchronize* synchronize_;
  ::chat::connectedUserRequest* connectedusers_;
  ::chat::ChangeStatusRequest* changestatus_;
  ::chat::BroadcastRequest* broadcast_;
  ::chat::DirectMessageRequest* directmessage_;
  ::chat::MyInfoAcknowledge* acknowledge_;
  ::PROTOBUF_NAMESPACE_ID::int32 option_;
  ::PROTOBUF_NAMESPACE_ID::int32 userid_;
  friend struct ::TableStruct_mensaje_2eproto;
};
// -------------------------------------------------------------------

class ServerResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat.ServerResponse) */ {
 public:
  inline ServerResponse() : ServerResponse(nullptr) {};
  virtual ~ServerResponse();

  ServerResponse(const ServerResponse& from);
  ServerResponse(ServerResponse&& from) noexcept
    : ServerResponse() {
    *this = ::std::move(from);
  }

  inline ServerResponse& operator=(const ServerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerResponse& operator=(ServerResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ServerResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerResponse* internal_default_instance() {
    return reinterpret_cast<const ServerResponse*>(
               &_ServerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ServerResponse& a, ServerResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ServerResponse* New() const final {
    return CreateMaybeMessage<ServerResponse>(nullptr);
  }

  ServerResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServerResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ServerResponse& from);
  void MergeFrom(const ServerResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat.ServerResponse";
  }
  protected:
  explicit ServerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mensaje_2eproto);
    return ::descriptor_table_mensaje_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBroadcastFieldNumber = 2,
    kMessageFieldNumber = 3,
    kErrorFieldNumber = 4,
    kMyInfoResponseFieldNumber = 5,
    kConnectedUserResponseFieldNumber = 6,
    kChangeStatusResponseFieldNumber = 7,
    kBroadcastResponseFieldNumber = 8,
    kDirectMessageResponseFieldNumber = 9,
    kOptionFieldNumber = 1,
  };
  // optional .chat.BroadcastMessage broadcast = 2;
  bool has_broadcast() const;
  private:
  bool _internal_has_broadcast() const;
  public:
  void clear_broadcast();
  const ::chat::BroadcastMessage& broadcast() const;
  ::chat::BroadcastMessage* release_broadcast();
  ::chat::BroadcastMessage* mutable_broadcast();
  void set_allocated_broadcast(::chat::BroadcastMessage* broadcast);
  private:
  const ::chat::BroadcastMessage& _internal_broadcast() const;
  ::chat::BroadcastMessage* _internal_mutable_broadcast();
  public:
  void unsafe_arena_set_allocated_broadcast(
      ::chat::BroadcastMessage* broadcast);
  ::chat::BroadcastMessage* unsafe_arena_release_broadcast();

  // optional .chat.DirectMessage message = 3;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const ::chat::DirectMessage& message() const;
  ::chat::DirectMessage* release_message();
  ::chat::DirectMessage* mutable_message();
  void set_allocated_message(::chat::DirectMessage* message);
  private:
  const ::chat::DirectMessage& _internal_message() const;
  ::chat::DirectMessage* _internal_mutable_message();
  public:
  void unsafe_arena_set_allocated_message(
      ::chat::DirectMessage* message);
  ::chat::DirectMessage* unsafe_arena_release_message();

  // optional .chat.ErrorResponse error = 4;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::chat::ErrorResponse& error() const;
  ::chat::ErrorResponse* release_error();
  ::chat::ErrorResponse* mutable_error();
  void set_allocated_error(::chat::ErrorResponse* error);
  private:
  const ::chat::ErrorResponse& _internal_error() const;
  ::chat::ErrorResponse* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::chat::ErrorResponse* error);
  ::chat::ErrorResponse* unsafe_arena_release_error();

  // optional .chat.MyInfoResponse myInfoResponse = 5;
  bool has_myinforesponse() const;
  private:
  bool _internal_has_myinforesponse() const;
  public:
  void clear_myinforesponse();
  const ::chat::MyInfoResponse& myinforesponse() const;
  ::chat::MyInfoResponse* release_myinforesponse();
  ::chat::MyInfoResponse* mutable_myinforesponse();
  void set_allocated_myinforesponse(::chat::MyInfoResponse* myinforesponse);
  private:
  const ::chat::MyInfoResponse& _internal_myinforesponse() const;
  ::chat::MyInfoResponse* _internal_mutable_myinforesponse();
  public:
  void unsafe_arena_set_allocated_myinforesponse(
      ::chat::MyInfoResponse* myinforesponse);
  ::chat::MyInfoResponse* unsafe_arena_release_myinforesponse();

  // optional .chat.ConnectedUserResponse connectedUserResponse = 6;
  bool has_connecteduserresponse() const;
  private:
  bool _internal_has_connecteduserresponse() const;
  public:
  void clear_connecteduserresponse();
  const ::chat::ConnectedUserResponse& connecteduserresponse() const;
  ::chat::ConnectedUserResponse* release_connecteduserresponse();
  ::chat::ConnectedUserResponse* mutable_connecteduserresponse();
  void set_allocated_connecteduserresponse(::chat::ConnectedUserResponse* connecteduserresponse);
  private:
  const ::chat::ConnectedUserResponse& _internal_connecteduserresponse() const;
  ::chat::ConnectedUserResponse* _internal_mutable_connecteduserresponse();
  public:
  void unsafe_arena_set_allocated_connecteduserresponse(
      ::chat::ConnectedUserResponse* connecteduserresponse);
  ::chat::ConnectedUserResponse* unsafe_arena_release_connecteduserresponse();

  // optional .chat.ChangeStatusResponse changeStatusResponse = 7;
  bool has_changestatusresponse() const;
  private:
  bool _internal_has_changestatusresponse() const;
  public:
  void clear_changestatusresponse();
  const ::chat::ChangeStatusResponse& changestatusresponse() const;
  ::chat::ChangeStatusResponse* release_changestatusresponse();
  ::chat::ChangeStatusResponse* mutable_changestatusresponse();
  void set_allocated_changestatusresponse(::chat::ChangeStatusResponse* changestatusresponse);
  private:
  const ::chat::ChangeStatusResponse& _internal_changestatusresponse() const;
  ::chat::ChangeStatusResponse* _internal_mutable_changestatusresponse();
  public:
  void unsafe_arena_set_allocated_changestatusresponse(
      ::chat::ChangeStatusResponse* changestatusresponse);
  ::chat::ChangeStatusResponse* unsafe_arena_release_changestatusresponse();

  // optional .chat.BroadcastResponse broadcastResponse = 8;
  bool has_broadcastresponse() const;
  private:
  bool _internal_has_broadcastresponse() const;
  public:
  void clear_broadcastresponse();
  const ::chat::BroadcastResponse& broadcastresponse() const;
  ::chat::BroadcastResponse* release_broadcastresponse();
  ::chat::BroadcastResponse* mutable_broadcastresponse();
  void set_allocated_broadcastresponse(::chat::BroadcastResponse* broadcastresponse);
  private:
  const ::chat::BroadcastResponse& _internal_broadcastresponse() const;
  ::chat::BroadcastResponse* _internal_mutable_broadcastresponse();
  public:
  void unsafe_arena_set_allocated_broadcastresponse(
      ::chat::BroadcastResponse* broadcastresponse);
  ::chat::BroadcastResponse* unsafe_arena_release_broadcastresponse();

  // optional .chat.DirectMessageResponse directMessageResponse = 9;
  bool has_directmessageresponse() const;
  private:
  bool _internal_has_directmessageresponse() const;
  public:
  void clear_directmessageresponse();
  const ::chat::DirectMessageResponse& directmessageresponse() const;
  ::chat::DirectMessageResponse* release_directmessageresponse();
  ::chat::DirectMessageResponse* mutable_directmessageresponse();
  void set_allocated_directmessageresponse(::chat::DirectMessageResponse* directmessageresponse);
  private:
  const ::chat::DirectMessageResponse& _internal_directmessageresponse() const;
  ::chat::DirectMessageResponse* _internal_mutable_directmessageresponse();
  public:
  void unsafe_arena_set_allocated_directmessageresponse(
      ::chat::DirectMessageResponse* directmessageresponse);
  ::chat::DirectMessageResponse* unsafe_arena_release_directmessageresponse();

  // required int32 option = 1;
  bool has_option() const;
  private:
  bool _internal_has_option() const;
  public:
  void clear_option();
  ::PROTOBUF_NAMESPACE_ID::int32 option() const;
  void set_option(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_option() const;
  void _internal_set_option(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:chat.ServerResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::chat::BroadcastMessage* broadcast_;
  ::chat::DirectMessage* message_;
  ::chat::ErrorResponse* error_;
  ::chat::MyInfoResponse* myinforesponse_;
  ::chat::ConnectedUserResponse* connecteduserresponse_;
  ::chat::ChangeStatusResponse* changestatusresponse_;
  ::chat::BroadcastResponse* broadcastresponse_;
  ::chat::DirectMessageResponse* directmessageresponse_;
  ::PROTOBUF_NAMESPACE_ID::int32 option_;
  friend struct ::TableStruct_mensaje_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MyInfoSynchronize

// required string username = 1;
inline bool MyInfoSynchronize::_internal_has_username() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MyInfoSynchronize::has_username() const {
  return _internal_has_username();
}
inline void MyInfoSynchronize::clear_username() {
  username_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MyInfoSynchronize::username() const {
  // @@protoc_insertion_point(field_get:chat.MyInfoSynchronize.username)
  return _internal_username();
}
inline void MyInfoSynchronize::set_username(const std::string& value) {
  _internal_set_username(value);
  // @@protoc_insertion_point(field_set:chat.MyInfoSynchronize.username)
}
inline std::string* MyInfoSynchronize::mutable_username() {
  // @@protoc_insertion_point(field_mutable:chat.MyInfoSynchronize.username)
  return _internal_mutable_username();
}
inline const std::string& MyInfoSynchronize::_internal_username() const {
  return username_.Get();
}
inline void MyInfoSynchronize::_internal_set_username(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void MyInfoSynchronize::set_username(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  username_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:chat.MyInfoSynchronize.username)
}
inline void MyInfoSynchronize::set_username(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:chat.MyInfoSynchronize.username)
}
inline void MyInfoSynchronize::set_username(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:chat.MyInfoSynchronize.username)
}
inline std::string* MyInfoSynchronize::_internal_mutable_username() {
  _has_bits_[0] |= 0x00000001u;
  return username_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* MyInfoSynchronize::release_username() {
  // @@protoc_insertion_point(field_release:chat.MyInfoSynchronize.username)
  if (!_internal_has_username()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return username_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MyInfoSynchronize::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:chat.MyInfoSynchronize.username)
}
inline std::string* MyInfoSynchronize::unsafe_arena_release_username() {
  // @@protoc_insertion_point(field_unsafe_arena_release:chat.MyInfoSynchronize.username)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return username_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void MyInfoSynchronize::unsafe_arena_set_allocated_username(
    std::string* username) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (username != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  username_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      username, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.MyInfoSynchronize.username)
}

// optional string ip = 2;
inline bool MyInfoSynchronize::_internal_has_ip() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MyInfoSynchronize::has_ip() const {
  return _internal_has_ip();
}
inline void MyInfoSynchronize::clear_ip() {
  ip_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MyInfoSynchronize::ip() const {
  // @@protoc_insertion_point(field_get:chat.MyInfoSynchronize.ip)
  return _internal_ip();
}
inline void MyInfoSynchronize::set_ip(const std::string& value) {
  _internal_set_ip(value);
  // @@protoc_insertion_point(field_set:chat.MyInfoSynchronize.ip)
}
inline std::string* MyInfoSynchronize::mutable_ip() {
  // @@protoc_insertion_point(field_mutable:chat.MyInfoSynchronize.ip)
  return _internal_mutable_ip();
}
inline const std::string& MyInfoSynchronize::_internal_ip() const {
  return ip_.Get();
}
inline void MyInfoSynchronize::_internal_set_ip(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void MyInfoSynchronize::set_ip(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  ip_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:chat.MyInfoSynchronize.ip)
}
inline void MyInfoSynchronize::set_ip(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:chat.MyInfoSynchronize.ip)
}
inline void MyInfoSynchronize::set_ip(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:chat.MyInfoSynchronize.ip)
}
inline std::string* MyInfoSynchronize::_internal_mutable_ip() {
  _has_bits_[0] |= 0x00000002u;
  return ip_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* MyInfoSynchronize::release_ip() {
  // @@protoc_insertion_point(field_release:chat.MyInfoSynchronize.ip)
  if (!_internal_has_ip()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return ip_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MyInfoSynchronize::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  ip_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:chat.MyInfoSynchronize.ip)
}
inline std::string* MyInfoSynchronize::unsafe_arena_release_ip() {
  // @@protoc_insertion_point(field_unsafe_arena_release:chat.MyInfoSynchronize.ip)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return ip_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void MyInfoSynchronize::unsafe_arena_set_allocated_ip(
    std::string* ip) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (ip != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  ip_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ip, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.MyInfoSynchronize.ip)
}

// -------------------------------------------------------------------

// MyInfoResponse

// required int32 userId = 1;
inline bool MyInfoResponse::_internal_has_userid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MyInfoResponse::has_userid() const {
  return _internal_has_userid();
}
inline void MyInfoResponse::clear_userid() {
  userid_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MyInfoResponse::_internal_userid() const {
  return userid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MyInfoResponse::userid() const {
  // @@protoc_insertion_point(field_get:chat.MyInfoResponse.userId)
  return _internal_userid();
}
inline void MyInfoResponse::_internal_set_userid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  userid_ = value;
}
inline void MyInfoResponse::set_userid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_userid(value);
  // @@protoc_insertion_point(field_set:chat.MyInfoResponse.userId)
}

// -------------------------------------------------------------------

// MyInfoAcknowledge

// required int32 userId = 1;
inline bool MyInfoAcknowledge::_internal_has_userid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MyInfoAcknowledge::has_userid() const {
  return _internal_has_userid();
}
inline void MyInfoAcknowledge::clear_userid() {
  userid_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MyInfoAcknowledge::_internal_userid() const {
  return userid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MyInfoAcknowledge::userid() const {
  // @@protoc_insertion_point(field_get:chat.MyInfoAcknowledge.userId)
  return _internal_userid();
}
inline void MyInfoAcknowledge::_internal_set_userid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  userid_ = value;
}
inline void MyInfoAcknowledge::set_userid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_userid(value);
  // @@protoc_insertion_point(field_set:chat.MyInfoAcknowledge.userId)
}

// -------------------------------------------------------------------

// connectedUserRequest

// optional int32 userId = 1;
inline bool connectedUserRequest::_internal_has_userid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool connectedUserRequest::has_userid() const {
  return _internal_has_userid();
}
inline void connectedUserRequest::clear_userid() {
  userid_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 connectedUserRequest::_internal_userid() const {
  return userid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 connectedUserRequest::userid() const {
  // @@protoc_insertion_point(field_get:chat.connectedUserRequest.userId)
  return _internal_userid();
}
inline void connectedUserRequest::_internal_set_userid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  userid_ = value;
}
inline void connectedUserRequest::set_userid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_userid(value);
  // @@protoc_insertion_point(field_set:chat.connectedUserRequest.userId)
}

// optional string username = 2;
inline bool connectedUserRequest::_internal_has_username() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool connectedUserRequest::has_username() const {
  return _internal_has_username();
}
inline void connectedUserRequest::clear_username() {
  username_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& connectedUserRequest::username() const {
  // @@protoc_insertion_point(field_get:chat.connectedUserRequest.username)
  return _internal_username();
}
inline void connectedUserRequest::set_username(const std::string& value) {
  _internal_set_username(value);
  // @@protoc_insertion_point(field_set:chat.connectedUserRequest.username)
}
inline std::string* connectedUserRequest::mutable_username() {
  // @@protoc_insertion_point(field_mutable:chat.connectedUserRequest.username)
  return _internal_mutable_username();
}
inline const std::string& connectedUserRequest::_internal_username() const {
  return username_.Get();
}
inline void connectedUserRequest::_internal_set_username(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void connectedUserRequest::set_username(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  username_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:chat.connectedUserRequest.username)
}
inline void connectedUserRequest::set_username(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:chat.connectedUserRequest.username)
}
inline void connectedUserRequest::set_username(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:chat.connectedUserRequest.username)
}
inline std::string* connectedUserRequest::_internal_mutable_username() {
  _has_bits_[0] |= 0x00000001u;
  return username_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* connectedUserRequest::release_username() {
  // @@protoc_insertion_point(field_release:chat.connectedUserRequest.username)
  if (!_internal_has_username()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return username_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void connectedUserRequest::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:chat.connectedUserRequest.username)
}
inline std::string* connectedUserRequest::unsafe_arena_release_username() {
  // @@protoc_insertion_point(field_unsafe_arena_release:chat.connectedUserRequest.username)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return username_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void connectedUserRequest::unsafe_arena_set_allocated_username(
    std::string* username) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (username != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  username_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      username, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.connectedUserRequest.username)
}

// -------------------------------------------------------------------

// ConnectedUser

// required string username = 1;
inline bool ConnectedUser::_internal_has_username() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ConnectedUser::has_username() const {
  return _internal_has_username();
}
inline void ConnectedUser::clear_username() {
  username_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ConnectedUser::username() const {
  // @@protoc_insertion_point(field_get:chat.ConnectedUser.username)
  return _internal_username();
}
inline void ConnectedUser::set_username(const std::string& value) {
  _internal_set_username(value);
  // @@protoc_insertion_point(field_set:chat.ConnectedUser.username)
}
inline std::string* ConnectedUser::mutable_username() {
  // @@protoc_insertion_point(field_mutable:chat.ConnectedUser.username)
  return _internal_mutable_username();
}
inline const std::string& ConnectedUser::_internal_username() const {
  return username_.Get();
}
inline void ConnectedUser::_internal_set_username(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ConnectedUser::set_username(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  username_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:chat.ConnectedUser.username)
}
inline void ConnectedUser::set_username(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:chat.ConnectedUser.username)
}
inline void ConnectedUser::set_username(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:chat.ConnectedUser.username)
}
inline std::string* ConnectedUser::_internal_mutable_username() {
  _has_bits_[0] |= 0x00000001u;
  return username_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ConnectedUser::release_username() {
  // @@protoc_insertion_point(field_release:chat.ConnectedUser.username)
  if (!_internal_has_username()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return username_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ConnectedUser::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:chat.ConnectedUser.username)
}
inline std::string* ConnectedUser::unsafe_arena_release_username() {
  // @@protoc_insertion_point(field_unsafe_arena_release:chat.ConnectedUser.username)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return username_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ConnectedUser::unsafe_arena_set_allocated_username(
    std::string* username) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (username != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  username_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      username, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.ConnectedUser.username)
}

// optional string status = 2;
inline bool ConnectedUser::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ConnectedUser::has_status() const {
  return _internal_has_status();
}
inline void ConnectedUser::clear_status() {
  status_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ConnectedUser::status() const {
  // @@protoc_insertion_point(field_get:chat.ConnectedUser.status)
  return _internal_status();
}
inline void ConnectedUser::set_status(const std::string& value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:chat.ConnectedUser.status)
}
inline std::string* ConnectedUser::mutable_status() {
  // @@protoc_insertion_point(field_mutable:chat.ConnectedUser.status)
  return _internal_mutable_status();
}
inline const std::string& ConnectedUser::_internal_status() const {
  return status_.Get();
}
inline void ConnectedUser::_internal_set_status(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  status_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ConnectedUser::set_status(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  status_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:chat.ConnectedUser.status)
}
inline void ConnectedUser::set_status(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  status_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:chat.ConnectedUser.status)
}
inline void ConnectedUser::set_status(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  status_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:chat.ConnectedUser.status)
}
inline std::string* ConnectedUser::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000002u;
  return status_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ConnectedUser::release_status() {
  // @@protoc_insertion_point(field_release:chat.ConnectedUser.status)
  if (!_internal_has_status()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return status_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ConnectedUser::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:chat.ConnectedUser.status)
}
inline std::string* ConnectedUser::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_unsafe_arena_release:chat.ConnectedUser.status)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return status_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ConnectedUser::unsafe_arena_set_allocated_status(
    std::string* status) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (status != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  status_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      status, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.ConnectedUser.status)
}

// optional int32 userId = 3;
inline bool ConnectedUser::_internal_has_userid() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ConnectedUser::has_userid() const {
  return _internal_has_userid();
}
inline void ConnectedUser::clear_userid() {
  userid_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ConnectedUser::_internal_userid() const {
  return userid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ConnectedUser::userid() const {
  // @@protoc_insertion_point(field_get:chat.ConnectedUser.userId)
  return _internal_userid();
}
inline void ConnectedUser::_internal_set_userid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  userid_ = value;
}
inline void ConnectedUser::set_userid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_userid(value);
  // @@protoc_insertion_point(field_set:chat.ConnectedUser.userId)
}

// optional string ip = 4;
inline bool ConnectedUser::_internal_has_ip() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ConnectedUser::has_ip() const {
  return _internal_has_ip();
}
inline void ConnectedUser::clear_ip() {
  ip_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ConnectedUser::ip() const {
  // @@protoc_insertion_point(field_get:chat.ConnectedUser.ip)
  return _internal_ip();
}
inline void ConnectedUser::set_ip(const std::string& value) {
  _internal_set_ip(value);
  // @@protoc_insertion_point(field_set:chat.ConnectedUser.ip)
}
inline std::string* ConnectedUser::mutable_ip() {
  // @@protoc_insertion_point(field_mutable:chat.ConnectedUser.ip)
  return _internal_mutable_ip();
}
inline const std::string& ConnectedUser::_internal_ip() const {
  return ip_.Get();
}
inline void ConnectedUser::_internal_set_ip(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ConnectedUser::set_ip(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  ip_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:chat.ConnectedUser.ip)
}
inline void ConnectedUser::set_ip(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:chat.ConnectedUser.ip)
}
inline void ConnectedUser::set_ip(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:chat.ConnectedUser.ip)
}
inline std::string* ConnectedUser::_internal_mutable_ip() {
  _has_bits_[0] |= 0x00000004u;
  return ip_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ConnectedUser::release_ip() {
  // @@protoc_insertion_point(field_release:chat.ConnectedUser.ip)
  if (!_internal_has_ip()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return ip_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ConnectedUser::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  ip_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:chat.ConnectedUser.ip)
}
inline std::string* ConnectedUser::unsafe_arena_release_ip() {
  // @@protoc_insertion_point(field_unsafe_arena_release:chat.ConnectedUser.ip)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000004u;
  return ip_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ConnectedUser::unsafe_arena_set_allocated_ip(
    std::string* ip) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (ip != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  ip_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ip, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.ConnectedUser.ip)
}

// -------------------------------------------------------------------

// ConnectedUserResponse

// repeated .chat.ConnectedUser connectedUsers = 1;
inline int ConnectedUserResponse::_internal_connectedusers_size() const {
  return connectedusers_.size();
}
inline int ConnectedUserResponse::connectedusers_size() const {
  return _internal_connectedusers_size();
}
inline void ConnectedUserResponse::clear_connectedusers() {
  connectedusers_.Clear();
}
inline ::chat::ConnectedUser* ConnectedUserResponse::mutable_connectedusers(int index) {
  // @@protoc_insertion_point(field_mutable:chat.ConnectedUserResponse.connectedUsers)
  return connectedusers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chat::ConnectedUser >*
ConnectedUserResponse::mutable_connectedusers() {
  // @@protoc_insertion_point(field_mutable_list:chat.ConnectedUserResponse.connectedUsers)
  return &connectedusers_;
}
inline const ::chat::ConnectedUser& ConnectedUserResponse::_internal_connectedusers(int index) const {
  return connectedusers_.Get(index);
}
inline const ::chat::ConnectedUser& ConnectedUserResponse::connectedusers(int index) const {
  // @@protoc_insertion_point(field_get:chat.ConnectedUserResponse.connectedUsers)
  return _internal_connectedusers(index);
}
inline ::chat::ConnectedUser* ConnectedUserResponse::_internal_add_connectedusers() {
  return connectedusers_.Add();
}
inline ::chat::ConnectedUser* ConnectedUserResponse::add_connectedusers() {
  // @@protoc_insertion_point(field_add:chat.ConnectedUserResponse.connectedUsers)
  return _internal_add_connectedusers();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chat::ConnectedUser >&
ConnectedUserResponse::connectedusers() const {
  // @@protoc_insertion_point(field_list:chat.ConnectedUserResponse.connectedUsers)
  return connectedusers_;
}

// -------------------------------------------------------------------

// ChangeStatusRequest

// required string status = 1;
inline bool ChangeStatusRequest::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ChangeStatusRequest::has_status() const {
  return _internal_has_status();
}
inline void ChangeStatusRequest::clear_status() {
  status_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ChangeStatusRequest::status() const {
  // @@protoc_insertion_point(field_get:chat.ChangeStatusRequest.status)
  return _internal_status();
}
inline void ChangeStatusRequest::set_status(const std::string& value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:chat.ChangeStatusRequest.status)
}
inline std::string* ChangeStatusRequest::mutable_status() {
  // @@protoc_insertion_point(field_mutable:chat.ChangeStatusRequest.status)
  return _internal_mutable_status();
}
inline const std::string& ChangeStatusRequest::_internal_status() const {
  return status_.Get();
}
inline void ChangeStatusRequest::_internal_set_status(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  status_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ChangeStatusRequest::set_status(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  status_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:chat.ChangeStatusRequest.status)
}
inline void ChangeStatusRequest::set_status(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  status_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:chat.ChangeStatusRequest.status)
}
inline void ChangeStatusRequest::set_status(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  status_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:chat.ChangeStatusRequest.status)
}
inline std::string* ChangeStatusRequest::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000001u;
  return status_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ChangeStatusRequest::release_status() {
  // @@protoc_insertion_point(field_release:chat.ChangeStatusRequest.status)
  if (!_internal_has_status()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return status_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ChangeStatusRequest::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:chat.ChangeStatusRequest.status)
}
inline std::string* ChangeStatusRequest::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_unsafe_arena_release:chat.ChangeStatusRequest.status)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return status_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ChangeStatusRequest::unsafe_arena_set_allocated_status(
    std::string* status) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (status != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  status_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      status, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.ChangeStatusRequest.status)
}

// -------------------------------------------------------------------

// ChangeStatusResponse

// required int32 userId = 1;
inline bool ChangeStatusResponse::_internal_has_userid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ChangeStatusResponse::has_userid() const {
  return _internal_has_userid();
}
inline void ChangeStatusResponse::clear_userid() {
  userid_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ChangeStatusResponse::_internal_userid() const {
  return userid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ChangeStatusResponse::userid() const {
  // @@protoc_insertion_point(field_get:chat.ChangeStatusResponse.userId)
  return _internal_userid();
}
inline void ChangeStatusResponse::_internal_set_userid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  userid_ = value;
}
inline void ChangeStatusResponse::set_userid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_userid(value);
  // @@protoc_insertion_point(field_set:chat.ChangeStatusResponse.userId)
}

// required string status = 2;
inline bool ChangeStatusResponse::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ChangeStatusResponse::has_status() const {
  return _internal_has_status();
}
inline void ChangeStatusResponse::clear_status() {
  status_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ChangeStatusResponse::status() const {
  // @@protoc_insertion_point(field_get:chat.ChangeStatusResponse.status)
  return _internal_status();
}
inline void ChangeStatusResponse::set_status(const std::string& value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:chat.ChangeStatusResponse.status)
}
inline std::string* ChangeStatusResponse::mutable_status() {
  // @@protoc_insertion_point(field_mutable:chat.ChangeStatusResponse.status)
  return _internal_mutable_status();
}
inline const std::string& ChangeStatusResponse::_internal_status() const {
  return status_.Get();
}
inline void ChangeStatusResponse::_internal_set_status(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  status_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ChangeStatusResponse::set_status(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  status_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:chat.ChangeStatusResponse.status)
}
inline void ChangeStatusResponse::set_status(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  status_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:chat.ChangeStatusResponse.status)
}
inline void ChangeStatusResponse::set_status(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  status_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:chat.ChangeStatusResponse.status)
}
inline std::string* ChangeStatusResponse::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000001u;
  return status_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ChangeStatusResponse::release_status() {
  // @@protoc_insertion_point(field_release:chat.ChangeStatusResponse.status)
  if (!_internal_has_status()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return status_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ChangeStatusResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:chat.ChangeStatusResponse.status)
}
inline std::string* ChangeStatusResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_unsafe_arena_release:chat.ChangeStatusResponse.status)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return status_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ChangeStatusResponse::unsafe_arena_set_allocated_status(
    std::string* status) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (status != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  status_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      status, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.ChangeStatusResponse.status)
}

// -------------------------------------------------------------------

// BroadcastRequest

// required string message = 1;
inline bool BroadcastRequest::_internal_has_message() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BroadcastRequest::has_message() const {
  return _internal_has_message();
}
inline void BroadcastRequest::clear_message() {
  message_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BroadcastRequest::message() const {
  // @@protoc_insertion_point(field_get:chat.BroadcastRequest.message)
  return _internal_message();
}
inline void BroadcastRequest::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:chat.BroadcastRequest.message)
}
inline std::string* BroadcastRequest::mutable_message() {
  // @@protoc_insertion_point(field_mutable:chat.BroadcastRequest.message)
  return _internal_mutable_message();
}
inline const std::string& BroadcastRequest::_internal_message() const {
  return message_.Get();
}
inline void BroadcastRequest::_internal_set_message(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BroadcastRequest::set_message(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:chat.BroadcastRequest.message)
}
inline void BroadcastRequest::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:chat.BroadcastRequest.message)
}
inline void BroadcastRequest::set_message(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:chat.BroadcastRequest.message)
}
inline std::string* BroadcastRequest::_internal_mutable_message() {
  _has_bits_[0] |= 0x00000001u;
  return message_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* BroadcastRequest::release_message() {
  // @@protoc_insertion_point(field_release:chat.BroadcastRequest.message)
  if (!_internal_has_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return message_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BroadcastRequest::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:chat.BroadcastRequest.message)
}
inline std::string* BroadcastRequest::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:chat.BroadcastRequest.message)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return message_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void BroadcastRequest::unsafe_arena_set_allocated_message(
    std::string* message) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  message_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      message, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.BroadcastRequest.message)
}

// -------------------------------------------------------------------

// BroadcastResponse

// required string messageStatus = 1;
inline bool BroadcastResponse::_internal_has_messagestatus() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BroadcastResponse::has_messagestatus() const {
  return _internal_has_messagestatus();
}
inline void BroadcastResponse::clear_messagestatus() {
  messagestatus_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BroadcastResponse::messagestatus() const {
  // @@protoc_insertion_point(field_get:chat.BroadcastResponse.messageStatus)
  return _internal_messagestatus();
}
inline void BroadcastResponse::set_messagestatus(const std::string& value) {
  _internal_set_messagestatus(value);
  // @@protoc_insertion_point(field_set:chat.BroadcastResponse.messageStatus)
}
inline std::string* BroadcastResponse::mutable_messagestatus() {
  // @@protoc_insertion_point(field_mutable:chat.BroadcastResponse.messageStatus)
  return _internal_mutable_messagestatus();
}
inline const std::string& BroadcastResponse::_internal_messagestatus() const {
  return messagestatus_.Get();
}
inline void BroadcastResponse::_internal_set_messagestatus(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  messagestatus_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BroadcastResponse::set_messagestatus(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  messagestatus_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:chat.BroadcastResponse.messageStatus)
}
inline void BroadcastResponse::set_messagestatus(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  messagestatus_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:chat.BroadcastResponse.messageStatus)
}
inline void BroadcastResponse::set_messagestatus(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  messagestatus_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:chat.BroadcastResponse.messageStatus)
}
inline std::string* BroadcastResponse::_internal_mutable_messagestatus() {
  _has_bits_[0] |= 0x00000001u;
  return messagestatus_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* BroadcastResponse::release_messagestatus() {
  // @@protoc_insertion_point(field_release:chat.BroadcastResponse.messageStatus)
  if (!_internal_has_messagestatus()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return messagestatus_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BroadcastResponse::set_allocated_messagestatus(std::string* messagestatus) {
  if (messagestatus != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  messagestatus_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), messagestatus,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:chat.BroadcastResponse.messageStatus)
}
inline std::string* BroadcastResponse::unsafe_arena_release_messagestatus() {
  // @@protoc_insertion_point(field_unsafe_arena_release:chat.BroadcastResponse.messageStatus)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return messagestatus_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void BroadcastResponse::unsafe_arena_set_allocated_messagestatus(
    std::string* messagestatus) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (messagestatus != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  messagestatus_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      messagestatus, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.BroadcastResponse.messageStatus)
}

// -------------------------------------------------------------------

// BroadcastMessage

// required string message = 1;
inline bool BroadcastMessage::_internal_has_message() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BroadcastMessage::has_message() const {
  return _internal_has_message();
}
inline void BroadcastMessage::clear_message() {
  message_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BroadcastMessage::message() const {
  // @@protoc_insertion_point(field_get:chat.BroadcastMessage.message)
  return _internal_message();
}
inline void BroadcastMessage::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:chat.BroadcastMessage.message)
}
inline std::string* BroadcastMessage::mutable_message() {
  // @@protoc_insertion_point(field_mutable:chat.BroadcastMessage.message)
  return _internal_mutable_message();
}
inline const std::string& BroadcastMessage::_internal_message() const {
  return message_.Get();
}
inline void BroadcastMessage::_internal_set_message(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BroadcastMessage::set_message(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:chat.BroadcastMessage.message)
}
inline void BroadcastMessage::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:chat.BroadcastMessage.message)
}
inline void BroadcastMessage::set_message(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:chat.BroadcastMessage.message)
}
inline std::string* BroadcastMessage::_internal_mutable_message() {
  _has_bits_[0] |= 0x00000001u;
  return message_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* BroadcastMessage::release_message() {
  // @@protoc_insertion_point(field_release:chat.BroadcastMessage.message)
  if (!_internal_has_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return message_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BroadcastMessage::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:chat.BroadcastMessage.message)
}
inline std::string* BroadcastMessage::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:chat.BroadcastMessage.message)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return message_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void BroadcastMessage::unsafe_arena_set_allocated_message(
    std::string* message) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  message_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      message, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.BroadcastMessage.message)
}

// required int32 userId = 2;
inline bool BroadcastMessage::_internal_has_userid() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BroadcastMessage::has_userid() const {
  return _internal_has_userid();
}
inline void BroadcastMessage::clear_userid() {
  userid_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BroadcastMessage::_internal_userid() const {
  return userid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BroadcastMessage::userid() const {
  // @@protoc_insertion_point(field_get:chat.BroadcastMessage.userId)
  return _internal_userid();
}
inline void BroadcastMessage::_internal_set_userid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  userid_ = value;
}
inline void BroadcastMessage::set_userid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_userid(value);
  // @@protoc_insertion_point(field_set:chat.BroadcastMessage.userId)
}

// optional string username = 3;
inline bool BroadcastMessage::_internal_has_username() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BroadcastMessage::has_username() const {
  return _internal_has_username();
}
inline void BroadcastMessage::clear_username() {
  username_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BroadcastMessage::username() const {
  // @@protoc_insertion_point(field_get:chat.BroadcastMessage.username)
  return _internal_username();
}
inline void BroadcastMessage::set_username(const std::string& value) {
  _internal_set_username(value);
  // @@protoc_insertion_point(field_set:chat.BroadcastMessage.username)
}
inline std::string* BroadcastMessage::mutable_username() {
  // @@protoc_insertion_point(field_mutable:chat.BroadcastMessage.username)
  return _internal_mutable_username();
}
inline const std::string& BroadcastMessage::_internal_username() const {
  return username_.Get();
}
inline void BroadcastMessage::_internal_set_username(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BroadcastMessage::set_username(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  username_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:chat.BroadcastMessage.username)
}
inline void BroadcastMessage::set_username(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:chat.BroadcastMessage.username)
}
inline void BroadcastMessage::set_username(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:chat.BroadcastMessage.username)
}
inline std::string* BroadcastMessage::_internal_mutable_username() {
  _has_bits_[0] |= 0x00000002u;
  return username_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* BroadcastMessage::release_username() {
  // @@protoc_insertion_point(field_release:chat.BroadcastMessage.username)
  if (!_internal_has_username()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return username_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BroadcastMessage::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:chat.BroadcastMessage.username)
}
inline std::string* BroadcastMessage::unsafe_arena_release_username() {
  // @@protoc_insertion_point(field_unsafe_arena_release:chat.BroadcastMessage.username)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return username_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void BroadcastMessage::unsafe_arena_set_allocated_username(
    std::string* username) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (username != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  username_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      username, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.BroadcastMessage.username)
}

// -------------------------------------------------------------------

// DirectMessageRequest

// required string message = 1;
inline bool DirectMessageRequest::_internal_has_message() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DirectMessageRequest::has_message() const {
  return _internal_has_message();
}
inline void DirectMessageRequest::clear_message() {
  message_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DirectMessageRequest::message() const {
  // @@protoc_insertion_point(field_get:chat.DirectMessageRequest.message)
  return _internal_message();
}
inline void DirectMessageRequest::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:chat.DirectMessageRequest.message)
}
inline std::string* DirectMessageRequest::mutable_message() {
  // @@protoc_insertion_point(field_mutable:chat.DirectMessageRequest.message)
  return _internal_mutable_message();
}
inline const std::string& DirectMessageRequest::_internal_message() const {
  return message_.Get();
}
inline void DirectMessageRequest::_internal_set_message(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void DirectMessageRequest::set_message(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:chat.DirectMessageRequest.message)
}
inline void DirectMessageRequest::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:chat.DirectMessageRequest.message)
}
inline void DirectMessageRequest::set_message(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:chat.DirectMessageRequest.message)
}
inline std::string* DirectMessageRequest::_internal_mutable_message() {
  _has_bits_[0] |= 0x00000001u;
  return message_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* DirectMessageRequest::release_message() {
  // @@protoc_insertion_point(field_release:chat.DirectMessageRequest.message)
  if (!_internal_has_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return message_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DirectMessageRequest::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:chat.DirectMessageRequest.message)
}
inline std::string* DirectMessageRequest::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:chat.DirectMessageRequest.message)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return message_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void DirectMessageRequest::unsafe_arena_set_allocated_message(
    std::string* message) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  message_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      message, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.DirectMessageRequest.message)
}

// optional int32 userId = 2;
inline bool DirectMessageRequest::_internal_has_userid() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DirectMessageRequest::has_userid() const {
  return _internal_has_userid();
}
inline void DirectMessageRequest::clear_userid() {
  userid_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DirectMessageRequest::_internal_userid() const {
  return userid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DirectMessageRequest::userid() const {
  // @@protoc_insertion_point(field_get:chat.DirectMessageRequest.userId)
  return _internal_userid();
}
inline void DirectMessageRequest::_internal_set_userid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  userid_ = value;
}
inline void DirectMessageRequest::set_userid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_userid(value);
  // @@protoc_insertion_point(field_set:chat.DirectMessageRequest.userId)
}

// optional string username = 3;
inline bool DirectMessageRequest::_internal_has_username() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DirectMessageRequest::has_username() const {
  return _internal_has_username();
}
inline void DirectMessageRequest::clear_username() {
  username_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DirectMessageRequest::username() const {
  // @@protoc_insertion_point(field_get:chat.DirectMessageRequest.username)
  return _internal_username();
}
inline void DirectMessageRequest::set_username(const std::string& value) {
  _internal_set_username(value);
  // @@protoc_insertion_point(field_set:chat.DirectMessageRequest.username)
}
inline std::string* DirectMessageRequest::mutable_username() {
  // @@protoc_insertion_point(field_mutable:chat.DirectMessageRequest.username)
  return _internal_mutable_username();
}
inline const std::string& DirectMessageRequest::_internal_username() const {
  return username_.Get();
}
inline void DirectMessageRequest::_internal_set_username(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void DirectMessageRequest::set_username(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  username_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:chat.DirectMessageRequest.username)
}
inline void DirectMessageRequest::set_username(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:chat.DirectMessageRequest.username)
}
inline void DirectMessageRequest::set_username(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:chat.DirectMessageRequest.username)
}
inline std::string* DirectMessageRequest::_internal_mutable_username() {
  _has_bits_[0] |= 0x00000002u;
  return username_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* DirectMessageRequest::release_username() {
  // @@protoc_insertion_point(field_release:chat.DirectMessageRequest.username)
  if (!_internal_has_username()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return username_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DirectMessageRequest::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:chat.DirectMessageRequest.username)
}
inline std::string* DirectMessageRequest::unsafe_arena_release_username() {
  // @@protoc_insertion_point(field_unsafe_arena_release:chat.DirectMessageRequest.username)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return username_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void DirectMessageRequest::unsafe_arena_set_allocated_username(
    std::string* username) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (username != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  username_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      username, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.DirectMessageRequest.username)
}

// -------------------------------------------------------------------

// DirectMessageResponse

// required string messageStatus = 1;
inline bool DirectMessageResponse::_internal_has_messagestatus() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DirectMessageResponse::has_messagestatus() const {
  return _internal_has_messagestatus();
}
inline void DirectMessageResponse::clear_messagestatus() {
  messagestatus_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DirectMessageResponse::messagestatus() const {
  // @@protoc_insertion_point(field_get:chat.DirectMessageResponse.messageStatus)
  return _internal_messagestatus();
}
inline void DirectMessageResponse::set_messagestatus(const std::string& value) {
  _internal_set_messagestatus(value);
  // @@protoc_insertion_point(field_set:chat.DirectMessageResponse.messageStatus)
}
inline std::string* DirectMessageResponse::mutable_messagestatus() {
  // @@protoc_insertion_point(field_mutable:chat.DirectMessageResponse.messageStatus)
  return _internal_mutable_messagestatus();
}
inline const std::string& DirectMessageResponse::_internal_messagestatus() const {
  return messagestatus_.Get();
}
inline void DirectMessageResponse::_internal_set_messagestatus(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  messagestatus_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void DirectMessageResponse::set_messagestatus(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  messagestatus_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:chat.DirectMessageResponse.messageStatus)
}
inline void DirectMessageResponse::set_messagestatus(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  messagestatus_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:chat.DirectMessageResponse.messageStatus)
}
inline void DirectMessageResponse::set_messagestatus(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  messagestatus_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:chat.DirectMessageResponse.messageStatus)
}
inline std::string* DirectMessageResponse::_internal_mutable_messagestatus() {
  _has_bits_[0] |= 0x00000001u;
  return messagestatus_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* DirectMessageResponse::release_messagestatus() {
  // @@protoc_insertion_point(field_release:chat.DirectMessageResponse.messageStatus)
  if (!_internal_has_messagestatus()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return messagestatus_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DirectMessageResponse::set_allocated_messagestatus(std::string* messagestatus) {
  if (messagestatus != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  messagestatus_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), messagestatus,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:chat.DirectMessageResponse.messageStatus)
}
inline std::string* DirectMessageResponse::unsafe_arena_release_messagestatus() {
  // @@protoc_insertion_point(field_unsafe_arena_release:chat.DirectMessageResponse.messageStatus)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return messagestatus_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void DirectMessageResponse::unsafe_arena_set_allocated_messagestatus(
    std::string* messagestatus) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (messagestatus != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  messagestatus_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      messagestatus, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.DirectMessageResponse.messageStatus)
}

// -------------------------------------------------------------------

// DirectMessage

// required string message = 1;
inline bool DirectMessage::_internal_has_message() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DirectMessage::has_message() const {
  return _internal_has_message();
}
inline void DirectMessage::clear_message() {
  message_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DirectMessage::message() const {
  // @@protoc_insertion_point(field_get:chat.DirectMessage.message)
  return _internal_message();
}
inline void DirectMessage::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:chat.DirectMessage.message)
}
inline std::string* DirectMessage::mutable_message() {
  // @@protoc_insertion_point(field_mutable:chat.DirectMessage.message)
  return _internal_mutable_message();
}
inline const std::string& DirectMessage::_internal_message() const {
  return message_.Get();
}
inline void DirectMessage::_internal_set_message(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void DirectMessage::set_message(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:chat.DirectMessage.message)
}
inline void DirectMessage::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:chat.DirectMessage.message)
}
inline void DirectMessage::set_message(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:chat.DirectMessage.message)
}
inline std::string* DirectMessage::_internal_mutable_message() {
  _has_bits_[0] |= 0x00000001u;
  return message_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* DirectMessage::release_message() {
  // @@protoc_insertion_point(field_release:chat.DirectMessage.message)
  if (!_internal_has_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return message_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DirectMessage::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:chat.DirectMessage.message)
}
inline std::string* DirectMessage::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:chat.DirectMessage.message)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return message_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void DirectMessage::unsafe_arena_set_allocated_message(
    std::string* message) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  message_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      message, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.DirectMessage.message)
}

// required int32 userId = 2;
inline bool DirectMessage::_internal_has_userid() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DirectMessage::has_userid() const {
  return _internal_has_userid();
}
inline void DirectMessage::clear_userid() {
  userid_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DirectMessage::_internal_userid() const {
  return userid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DirectMessage::userid() const {
  // @@protoc_insertion_point(field_get:chat.DirectMessage.userId)
  return _internal_userid();
}
inline void DirectMessage::_internal_set_userid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  userid_ = value;
}
inline void DirectMessage::set_userid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_userid(value);
  // @@protoc_insertion_point(field_set:chat.DirectMessage.userId)
}

// optional string username = 3;
inline bool DirectMessage::_internal_has_username() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DirectMessage::has_username() const {
  return _internal_has_username();
}
inline void DirectMessage::clear_username() {
  username_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DirectMessage::username() const {
  // @@protoc_insertion_point(field_get:chat.DirectMessage.username)
  return _internal_username();
}
inline void DirectMessage::set_username(const std::string& value) {
  _internal_set_username(value);
  // @@protoc_insertion_point(field_set:chat.DirectMessage.username)
}
inline std::string* DirectMessage::mutable_username() {
  // @@protoc_insertion_point(field_mutable:chat.DirectMessage.username)
  return _internal_mutable_username();
}
inline const std::string& DirectMessage::_internal_username() const {
  return username_.Get();
}
inline void DirectMessage::_internal_set_username(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void DirectMessage::set_username(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  username_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:chat.DirectMessage.username)
}
inline void DirectMessage::set_username(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:chat.DirectMessage.username)
}
inline void DirectMessage::set_username(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:chat.DirectMessage.username)
}
inline std::string* DirectMessage::_internal_mutable_username() {
  _has_bits_[0] |= 0x00000002u;
  return username_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* DirectMessage::release_username() {
  // @@protoc_insertion_point(field_release:chat.DirectMessage.username)
  if (!_internal_has_username()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return username_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DirectMessage::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:chat.DirectMessage.username)
}
inline std::string* DirectMessage::unsafe_arena_release_username() {
  // @@protoc_insertion_point(field_unsafe_arena_release:chat.DirectMessage.username)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return username_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void DirectMessage::unsafe_arena_set_allocated_username(
    std::string* username) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (username != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  username_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      username, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.DirectMessage.username)
}

// -------------------------------------------------------------------

// ErrorResponse

// required string errorMessage = 1;
inline bool ErrorResponse::_internal_has_errormessage() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ErrorResponse::has_errormessage() const {
  return _internal_has_errormessage();
}
inline void ErrorResponse::clear_errormessage() {
  errormessage_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ErrorResponse::errormessage() const {
  // @@protoc_insertion_point(field_get:chat.ErrorResponse.errorMessage)
  return _internal_errormessage();
}
inline void ErrorResponse::set_errormessage(const std::string& value) {
  _internal_set_errormessage(value);
  // @@protoc_insertion_point(field_set:chat.ErrorResponse.errorMessage)
}
inline std::string* ErrorResponse::mutable_errormessage() {
  // @@protoc_insertion_point(field_mutable:chat.ErrorResponse.errorMessage)
  return _internal_mutable_errormessage();
}
inline const std::string& ErrorResponse::_internal_errormessage() const {
  return errormessage_.Get();
}
inline void ErrorResponse::_internal_set_errormessage(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  errormessage_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ErrorResponse::set_errormessage(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  errormessage_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:chat.ErrorResponse.errorMessage)
}
inline void ErrorResponse::set_errormessage(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  errormessage_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:chat.ErrorResponse.errorMessage)
}
inline void ErrorResponse::set_errormessage(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  errormessage_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:chat.ErrorResponse.errorMessage)
}
inline std::string* ErrorResponse::_internal_mutable_errormessage() {
  _has_bits_[0] |= 0x00000001u;
  return errormessage_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ErrorResponse::release_errormessage() {
  // @@protoc_insertion_point(field_release:chat.ErrorResponse.errorMessage)
  if (!_internal_has_errormessage()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return errormessage_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ErrorResponse::set_allocated_errormessage(std::string* errormessage) {
  if (errormessage != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  errormessage_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), errormessage,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:chat.ErrorResponse.errorMessage)
}
inline std::string* ErrorResponse::unsafe_arena_release_errormessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:chat.ErrorResponse.errorMessage)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return errormessage_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ErrorResponse::unsafe_arena_set_allocated_errormessage(
    std::string* errormessage) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (errormessage != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  errormessage_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      errormessage, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.ErrorResponse.errorMessage)
}

// -------------------------------------------------------------------

// ClientPetition

// required int32 option = 1;
inline bool ClientPetition::_internal_has_option() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ClientPetition::has_option() const {
  return _internal_has_option();
}
inline void ClientPetition::clear_option() {
  option_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ClientPetition::_internal_option() const {
  return option_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ClientPetition::option() const {
  // @@protoc_insertion_point(field_get:chat.ClientPetition.option)
  return _internal_option();
}
inline void ClientPetition::_internal_set_option(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000040u;
  option_ = value;
}
inline void ClientPetition::set_option(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_option(value);
  // @@protoc_insertion_point(field_set:chat.ClientPetition.option)
}

// optional int32 userId = 2;
inline bool ClientPetition::_internal_has_userid() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ClientPetition::has_userid() const {
  return _internal_has_userid();
}
inline void ClientPetition::clear_userid() {
  userid_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ClientPetition::_internal_userid() const {
  return userid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ClientPetition::userid() const {
  // @@protoc_insertion_point(field_get:chat.ClientPetition.userId)
  return _internal_userid();
}
inline void ClientPetition::_internal_set_userid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000080u;
  userid_ = value;
}
inline void ClientPetition::set_userid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_userid(value);
  // @@protoc_insertion_point(field_set:chat.ClientPetition.userId)
}

// optional .chat.MyInfoSynchronize synchronize = 3;
inline bool ClientPetition::_internal_has_synchronize() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || synchronize_ != nullptr);
  return value;
}
inline bool ClientPetition::has_synchronize() const {
  return _internal_has_synchronize();
}
inline void ClientPetition::clear_synchronize() {
  if (synchronize_ != nullptr) synchronize_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::chat::MyInfoSynchronize& ClientPetition::_internal_synchronize() const {
  const ::chat::MyInfoSynchronize* p = synchronize_;
  return p != nullptr ? *p : *reinterpret_cast<const ::chat::MyInfoSynchronize*>(
      &::chat::_MyInfoSynchronize_default_instance_);
}
inline const ::chat::MyInfoSynchronize& ClientPetition::synchronize() const {
  // @@protoc_insertion_point(field_get:chat.ClientPetition.synchronize)
  return _internal_synchronize();
}
inline void ClientPetition::unsafe_arena_set_allocated_synchronize(
    ::chat::MyInfoSynchronize* synchronize) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(synchronize_);
  }
  synchronize_ = synchronize;
  if (synchronize) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.ClientPetition.synchronize)
}
inline ::chat::MyInfoSynchronize* ClientPetition::release_synchronize() {
  auto temp = unsafe_arena_release_synchronize();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::chat::MyInfoSynchronize* ClientPetition::unsafe_arena_release_synchronize() {
  // @@protoc_insertion_point(field_release:chat.ClientPetition.synchronize)
  _has_bits_[0] &= ~0x00000001u;
  ::chat::MyInfoSynchronize* temp = synchronize_;
  synchronize_ = nullptr;
  return temp;
}
inline ::chat::MyInfoSynchronize* ClientPetition::_internal_mutable_synchronize() {
  _has_bits_[0] |= 0x00000001u;
  if (synchronize_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat::MyInfoSynchronize>(GetArena());
    synchronize_ = p;
  }
  return synchronize_;
}
inline ::chat::MyInfoSynchronize* ClientPetition::mutable_synchronize() {
  // @@protoc_insertion_point(field_mutable:chat.ClientPetition.synchronize)
  return _internal_mutable_synchronize();
}
inline void ClientPetition::set_allocated_synchronize(::chat::MyInfoSynchronize* synchronize) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete synchronize_;
  }
  if (synchronize) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(synchronize);
    if (message_arena != submessage_arena) {
      synchronize = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, synchronize, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  synchronize_ = synchronize;
  // @@protoc_insertion_point(field_set_allocated:chat.ClientPetition.synchronize)
}

// optional .chat.connectedUserRequest connectedUsers = 4;
inline bool ClientPetition::_internal_has_connectedusers() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || connectedusers_ != nullptr);
  return value;
}
inline bool ClientPetition::has_connectedusers() const {
  return _internal_has_connectedusers();
}
inline void ClientPetition::clear_connectedusers() {
  if (connectedusers_ != nullptr) connectedusers_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::chat::connectedUserRequest& ClientPetition::_internal_connectedusers() const {
  const ::chat::connectedUserRequest* p = connectedusers_;
  return p != nullptr ? *p : *reinterpret_cast<const ::chat::connectedUserRequest*>(
      &::chat::_connectedUserRequest_default_instance_);
}
inline const ::chat::connectedUserRequest& ClientPetition::connectedusers() const {
  // @@protoc_insertion_point(field_get:chat.ClientPetition.connectedUsers)
  return _internal_connectedusers();
}
inline void ClientPetition::unsafe_arena_set_allocated_connectedusers(
    ::chat::connectedUserRequest* connectedusers) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(connectedusers_);
  }
  connectedusers_ = connectedusers;
  if (connectedusers) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.ClientPetition.connectedUsers)
}
inline ::chat::connectedUserRequest* ClientPetition::release_connectedusers() {
  auto temp = unsafe_arena_release_connectedusers();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::chat::connectedUserRequest* ClientPetition::unsafe_arena_release_connectedusers() {
  // @@protoc_insertion_point(field_release:chat.ClientPetition.connectedUsers)
  _has_bits_[0] &= ~0x00000002u;
  ::chat::connectedUserRequest* temp = connectedusers_;
  connectedusers_ = nullptr;
  return temp;
}
inline ::chat::connectedUserRequest* ClientPetition::_internal_mutable_connectedusers() {
  _has_bits_[0] |= 0x00000002u;
  if (connectedusers_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat::connectedUserRequest>(GetArena());
    connectedusers_ = p;
  }
  return connectedusers_;
}
inline ::chat::connectedUserRequest* ClientPetition::mutable_connectedusers() {
  // @@protoc_insertion_point(field_mutable:chat.ClientPetition.connectedUsers)
  return _internal_mutable_connectedusers();
}
inline void ClientPetition::set_allocated_connectedusers(::chat::connectedUserRequest* connectedusers) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete connectedusers_;
  }
  if (connectedusers) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(connectedusers);
    if (message_arena != submessage_arena) {
      connectedusers = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, connectedusers, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  connectedusers_ = connectedusers;
  // @@protoc_insertion_point(field_set_allocated:chat.ClientPetition.connectedUsers)
}

// optional .chat.ChangeStatusRequest changeStatus = 5;
inline bool ClientPetition::_internal_has_changestatus() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || changestatus_ != nullptr);
  return value;
}
inline bool ClientPetition::has_changestatus() const {
  return _internal_has_changestatus();
}
inline void ClientPetition::clear_changestatus() {
  if (changestatus_ != nullptr) changestatus_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::chat::ChangeStatusRequest& ClientPetition::_internal_changestatus() const {
  const ::chat::ChangeStatusRequest* p = changestatus_;
  return p != nullptr ? *p : *reinterpret_cast<const ::chat::ChangeStatusRequest*>(
      &::chat::_ChangeStatusRequest_default_instance_);
}
inline const ::chat::ChangeStatusRequest& ClientPetition::changestatus() const {
  // @@protoc_insertion_point(field_get:chat.ClientPetition.changeStatus)
  return _internal_changestatus();
}
inline void ClientPetition::unsafe_arena_set_allocated_changestatus(
    ::chat::ChangeStatusRequest* changestatus) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(changestatus_);
  }
  changestatus_ = changestatus;
  if (changestatus) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.ClientPetition.changeStatus)
}
inline ::chat::ChangeStatusRequest* ClientPetition::release_changestatus() {
  auto temp = unsafe_arena_release_changestatus();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::chat::ChangeStatusRequest* ClientPetition::unsafe_arena_release_changestatus() {
  // @@protoc_insertion_point(field_release:chat.ClientPetition.changeStatus)
  _has_bits_[0] &= ~0x00000004u;
  ::chat::ChangeStatusRequest* temp = changestatus_;
  changestatus_ = nullptr;
  return temp;
}
inline ::chat::ChangeStatusRequest* ClientPetition::_internal_mutable_changestatus() {
  _has_bits_[0] |= 0x00000004u;
  if (changestatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat::ChangeStatusRequest>(GetArena());
    changestatus_ = p;
  }
  return changestatus_;
}
inline ::chat::ChangeStatusRequest* ClientPetition::mutable_changestatus() {
  // @@protoc_insertion_point(field_mutable:chat.ClientPetition.changeStatus)
  return _internal_mutable_changestatus();
}
inline void ClientPetition::set_allocated_changestatus(::chat::ChangeStatusRequest* changestatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete changestatus_;
  }
  if (changestatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(changestatus);
    if (message_arena != submessage_arena) {
      changestatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, changestatus, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  changestatus_ = changestatus;
  // @@protoc_insertion_point(field_set_allocated:chat.ClientPetition.changeStatus)
}

// optional .chat.BroadcastRequest broadcast = 6;
inline bool ClientPetition::_internal_has_broadcast() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || broadcast_ != nullptr);
  return value;
}
inline bool ClientPetition::has_broadcast() const {
  return _internal_has_broadcast();
}
inline void ClientPetition::clear_broadcast() {
  if (broadcast_ != nullptr) broadcast_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::chat::BroadcastRequest& ClientPetition::_internal_broadcast() const {
  const ::chat::BroadcastRequest* p = broadcast_;
  return p != nullptr ? *p : *reinterpret_cast<const ::chat::BroadcastRequest*>(
      &::chat::_BroadcastRequest_default_instance_);
}
inline const ::chat::BroadcastRequest& ClientPetition::broadcast() const {
  // @@protoc_insertion_point(field_get:chat.ClientPetition.broadcast)
  return _internal_broadcast();
}
inline void ClientPetition::unsafe_arena_set_allocated_broadcast(
    ::chat::BroadcastRequest* broadcast) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(broadcast_);
  }
  broadcast_ = broadcast;
  if (broadcast) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.ClientPetition.broadcast)
}
inline ::chat::BroadcastRequest* ClientPetition::release_broadcast() {
  auto temp = unsafe_arena_release_broadcast();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::chat::BroadcastRequest* ClientPetition::unsafe_arena_release_broadcast() {
  // @@protoc_insertion_point(field_release:chat.ClientPetition.broadcast)
  _has_bits_[0] &= ~0x00000008u;
  ::chat::BroadcastRequest* temp = broadcast_;
  broadcast_ = nullptr;
  return temp;
}
inline ::chat::BroadcastRequest* ClientPetition::_internal_mutable_broadcast() {
  _has_bits_[0] |= 0x00000008u;
  if (broadcast_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat::BroadcastRequest>(GetArena());
    broadcast_ = p;
  }
  return broadcast_;
}
inline ::chat::BroadcastRequest* ClientPetition::mutable_broadcast() {
  // @@protoc_insertion_point(field_mutable:chat.ClientPetition.broadcast)
  return _internal_mutable_broadcast();
}
inline void ClientPetition::set_allocated_broadcast(::chat::BroadcastRequest* broadcast) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete broadcast_;
  }
  if (broadcast) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(broadcast);
    if (message_arena != submessage_arena) {
      broadcast = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, broadcast, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  broadcast_ = broadcast;
  // @@protoc_insertion_point(field_set_allocated:chat.ClientPetition.broadcast)
}

// optional .chat.DirectMessageRequest directMessage = 7;
inline bool ClientPetition::_internal_has_directmessage() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || directmessage_ != nullptr);
  return value;
}
inline bool ClientPetition::has_directmessage() const {
  return _internal_has_directmessage();
}
inline void ClientPetition::clear_directmessage() {
  if (directmessage_ != nullptr) directmessage_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::chat::DirectMessageRequest& ClientPetition::_internal_directmessage() const {
  const ::chat::DirectMessageRequest* p = directmessage_;
  return p != nullptr ? *p : *reinterpret_cast<const ::chat::DirectMessageRequest*>(
      &::chat::_DirectMessageRequest_default_instance_);
}
inline const ::chat::DirectMessageRequest& ClientPetition::directmessage() const {
  // @@protoc_insertion_point(field_get:chat.ClientPetition.directMessage)
  return _internal_directmessage();
}
inline void ClientPetition::unsafe_arena_set_allocated_directmessage(
    ::chat::DirectMessageRequest* directmessage) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(directmessage_);
  }
  directmessage_ = directmessage;
  if (directmessage) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.ClientPetition.directMessage)
}
inline ::chat::DirectMessageRequest* ClientPetition::release_directmessage() {
  auto temp = unsafe_arena_release_directmessage();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::chat::DirectMessageRequest* ClientPetition::unsafe_arena_release_directmessage() {
  // @@protoc_insertion_point(field_release:chat.ClientPetition.directMessage)
  _has_bits_[0] &= ~0x00000010u;
  ::chat::DirectMessageRequest* temp = directmessage_;
  directmessage_ = nullptr;
  return temp;
}
inline ::chat::DirectMessageRequest* ClientPetition::_internal_mutable_directmessage() {
  _has_bits_[0] |= 0x00000010u;
  if (directmessage_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat::DirectMessageRequest>(GetArena());
    directmessage_ = p;
  }
  return directmessage_;
}
inline ::chat::DirectMessageRequest* ClientPetition::mutable_directmessage() {
  // @@protoc_insertion_point(field_mutable:chat.ClientPetition.directMessage)
  return _internal_mutable_directmessage();
}
inline void ClientPetition::set_allocated_directmessage(::chat::DirectMessageRequest* directmessage) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete directmessage_;
  }
  if (directmessage) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(directmessage);
    if (message_arena != submessage_arena) {
      directmessage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, directmessage, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  directmessage_ = directmessage;
  // @@protoc_insertion_point(field_set_allocated:chat.ClientPetition.directMessage)
}

// optional .chat.MyInfoAcknowledge acknowledge = 8;
inline bool ClientPetition::_internal_has_acknowledge() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || acknowledge_ != nullptr);
  return value;
}
inline bool ClientPetition::has_acknowledge() const {
  return _internal_has_acknowledge();
}
inline void ClientPetition::clear_acknowledge() {
  if (acknowledge_ != nullptr) acknowledge_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::chat::MyInfoAcknowledge& ClientPetition::_internal_acknowledge() const {
  const ::chat::MyInfoAcknowledge* p = acknowledge_;
  return p != nullptr ? *p : *reinterpret_cast<const ::chat::MyInfoAcknowledge*>(
      &::chat::_MyInfoAcknowledge_default_instance_);
}
inline const ::chat::MyInfoAcknowledge& ClientPetition::acknowledge() const {
  // @@protoc_insertion_point(field_get:chat.ClientPetition.acknowledge)
  return _internal_acknowledge();
}
inline void ClientPetition::unsafe_arena_set_allocated_acknowledge(
    ::chat::MyInfoAcknowledge* acknowledge) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(acknowledge_);
  }
  acknowledge_ = acknowledge;
  if (acknowledge) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.ClientPetition.acknowledge)
}
inline ::chat::MyInfoAcknowledge* ClientPetition::release_acknowledge() {
  auto temp = unsafe_arena_release_acknowledge();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::chat::MyInfoAcknowledge* ClientPetition::unsafe_arena_release_acknowledge() {
  // @@protoc_insertion_point(field_release:chat.ClientPetition.acknowledge)
  _has_bits_[0] &= ~0x00000020u;
  ::chat::MyInfoAcknowledge* temp = acknowledge_;
  acknowledge_ = nullptr;
  return temp;
}
inline ::chat::MyInfoAcknowledge* ClientPetition::_internal_mutable_acknowledge() {
  _has_bits_[0] |= 0x00000020u;
  if (acknowledge_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat::MyInfoAcknowledge>(GetArena());
    acknowledge_ = p;
  }
  return acknowledge_;
}
inline ::chat::MyInfoAcknowledge* ClientPetition::mutable_acknowledge() {
  // @@protoc_insertion_point(field_mutable:chat.ClientPetition.acknowledge)
  return _internal_mutable_acknowledge();
}
inline void ClientPetition::set_allocated_acknowledge(::chat::MyInfoAcknowledge* acknowledge) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete acknowledge_;
  }
  if (acknowledge) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(acknowledge);
    if (message_arena != submessage_arena) {
      acknowledge = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, acknowledge, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  acknowledge_ = acknowledge;
  // @@protoc_insertion_point(field_set_allocated:chat.ClientPetition.acknowledge)
}

// -------------------------------------------------------------------

// ServerResponse

// required int32 option = 1;
inline bool ServerResponse::_internal_has_option() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ServerResponse::has_option() const {
  return _internal_has_option();
}
inline void ServerResponse::clear_option() {
  option_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ServerResponse::_internal_option() const {
  return option_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ServerResponse::option() const {
  // @@protoc_insertion_point(field_get:chat.ServerResponse.option)
  return _internal_option();
}
inline void ServerResponse::_internal_set_option(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000100u;
  option_ = value;
}
inline void ServerResponse::set_option(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_option(value);
  // @@protoc_insertion_point(field_set:chat.ServerResponse.option)
}

// optional .chat.BroadcastMessage broadcast = 2;
inline bool ServerResponse::_internal_has_broadcast() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || broadcast_ != nullptr);
  return value;
}
inline bool ServerResponse::has_broadcast() const {
  return _internal_has_broadcast();
}
inline void ServerResponse::clear_broadcast() {
  if (broadcast_ != nullptr) broadcast_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::chat::BroadcastMessage& ServerResponse::_internal_broadcast() const {
  const ::chat::BroadcastMessage* p = broadcast_;
  return p != nullptr ? *p : *reinterpret_cast<const ::chat::BroadcastMessage*>(
      &::chat::_BroadcastMessage_default_instance_);
}
inline const ::chat::BroadcastMessage& ServerResponse::broadcast() const {
  // @@protoc_insertion_point(field_get:chat.ServerResponse.broadcast)
  return _internal_broadcast();
}
inline void ServerResponse::unsafe_arena_set_allocated_broadcast(
    ::chat::BroadcastMessage* broadcast) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(broadcast_);
  }
  broadcast_ = broadcast;
  if (broadcast) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.ServerResponse.broadcast)
}
inline ::chat::BroadcastMessage* ServerResponse::release_broadcast() {
  auto temp = unsafe_arena_release_broadcast();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::chat::BroadcastMessage* ServerResponse::unsafe_arena_release_broadcast() {
  // @@protoc_insertion_point(field_release:chat.ServerResponse.broadcast)
  _has_bits_[0] &= ~0x00000001u;
  ::chat::BroadcastMessage* temp = broadcast_;
  broadcast_ = nullptr;
  return temp;
}
inline ::chat::BroadcastMessage* ServerResponse::_internal_mutable_broadcast() {
  _has_bits_[0] |= 0x00000001u;
  if (broadcast_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat::BroadcastMessage>(GetArena());
    broadcast_ = p;
  }
  return broadcast_;
}
inline ::chat::BroadcastMessage* ServerResponse::mutable_broadcast() {
  // @@protoc_insertion_point(field_mutable:chat.ServerResponse.broadcast)
  return _internal_mutable_broadcast();
}
inline void ServerResponse::set_allocated_broadcast(::chat::BroadcastMessage* broadcast) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete broadcast_;
  }
  if (broadcast) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(broadcast);
    if (message_arena != submessage_arena) {
      broadcast = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, broadcast, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  broadcast_ = broadcast;
  // @@protoc_insertion_point(field_set_allocated:chat.ServerResponse.broadcast)
}

// optional .chat.DirectMessage message = 3;
inline bool ServerResponse::_internal_has_message() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || message_ != nullptr);
  return value;
}
inline bool ServerResponse::has_message() const {
  return _internal_has_message();
}
inline void ServerResponse::clear_message() {
  if (message_ != nullptr) message_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::chat::DirectMessage& ServerResponse::_internal_message() const {
  const ::chat::DirectMessage* p = message_;
  return p != nullptr ? *p : *reinterpret_cast<const ::chat::DirectMessage*>(
      &::chat::_DirectMessage_default_instance_);
}
inline const ::chat::DirectMessage& ServerResponse::message() const {
  // @@protoc_insertion_point(field_get:chat.ServerResponse.message)
  return _internal_message();
}
inline void ServerResponse::unsafe_arena_set_allocated_message(
    ::chat::DirectMessage* message) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(message_);
  }
  message_ = message;
  if (message) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.ServerResponse.message)
}
inline ::chat::DirectMessage* ServerResponse::release_message() {
  auto temp = unsafe_arena_release_message();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::chat::DirectMessage* ServerResponse::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_release:chat.ServerResponse.message)
  _has_bits_[0] &= ~0x00000002u;
  ::chat::DirectMessage* temp = message_;
  message_ = nullptr;
  return temp;
}
inline ::chat::DirectMessage* ServerResponse::_internal_mutable_message() {
  _has_bits_[0] |= 0x00000002u;
  if (message_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat::DirectMessage>(GetArena());
    message_ = p;
  }
  return message_;
}
inline ::chat::DirectMessage* ServerResponse::mutable_message() {
  // @@protoc_insertion_point(field_mutable:chat.ServerResponse.message)
  return _internal_mutable_message();
}
inline void ServerResponse::set_allocated_message(::chat::DirectMessage* message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete message_;
  }
  if (message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(message);
    if (message_arena != submessage_arena) {
      message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, message, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  message_ = message;
  // @@protoc_insertion_point(field_set_allocated:chat.ServerResponse.message)
}

// optional .chat.ErrorResponse error = 4;
inline bool ServerResponse::_internal_has_error() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || error_ != nullptr);
  return value;
}
inline bool ServerResponse::has_error() const {
  return _internal_has_error();
}
inline void ServerResponse::clear_error() {
  if (error_ != nullptr) error_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::chat::ErrorResponse& ServerResponse::_internal_error() const {
  const ::chat::ErrorResponse* p = error_;
  return p != nullptr ? *p : *reinterpret_cast<const ::chat::ErrorResponse*>(
      &::chat::_ErrorResponse_default_instance_);
}
inline const ::chat::ErrorResponse& ServerResponse::error() const {
  // @@protoc_insertion_point(field_get:chat.ServerResponse.error)
  return _internal_error();
}
inline void ServerResponse::unsafe_arena_set_allocated_error(
    ::chat::ErrorResponse* error) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(error_);
  }
  error_ = error;
  if (error) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.ServerResponse.error)
}
inline ::chat::ErrorResponse* ServerResponse::release_error() {
  auto temp = unsafe_arena_release_error();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::chat::ErrorResponse* ServerResponse::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:chat.ServerResponse.error)
  _has_bits_[0] &= ~0x00000004u;
  ::chat::ErrorResponse* temp = error_;
  error_ = nullptr;
  return temp;
}
inline ::chat::ErrorResponse* ServerResponse::_internal_mutable_error() {
  _has_bits_[0] |= 0x00000004u;
  if (error_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat::ErrorResponse>(GetArena());
    error_ = p;
  }
  return error_;
}
inline ::chat::ErrorResponse* ServerResponse::mutable_error() {
  // @@protoc_insertion_point(field_mutable:chat.ServerResponse.error)
  return _internal_mutable_error();
}
inline void ServerResponse::set_allocated_error(::chat::ErrorResponse* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:chat.ServerResponse.error)
}

// optional .chat.MyInfoResponse myInfoResponse = 5;
inline bool ServerResponse::_internal_has_myinforesponse() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || myinforesponse_ != nullptr);
  return value;
}
inline bool ServerResponse::has_myinforesponse() const {
  return _internal_has_myinforesponse();
}
inline void ServerResponse::clear_myinforesponse() {
  if (myinforesponse_ != nullptr) myinforesponse_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::chat::MyInfoResponse& ServerResponse::_internal_myinforesponse() const {
  const ::chat::MyInfoResponse* p = myinforesponse_;
  return p != nullptr ? *p : *reinterpret_cast<const ::chat::MyInfoResponse*>(
      &::chat::_MyInfoResponse_default_instance_);
}
inline const ::chat::MyInfoResponse& ServerResponse::myinforesponse() const {
  // @@protoc_insertion_point(field_get:chat.ServerResponse.myInfoResponse)
  return _internal_myinforesponse();
}
inline void ServerResponse::unsafe_arena_set_allocated_myinforesponse(
    ::chat::MyInfoResponse* myinforesponse) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(myinforesponse_);
  }
  myinforesponse_ = myinforesponse;
  if (myinforesponse) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.ServerResponse.myInfoResponse)
}
inline ::chat::MyInfoResponse* ServerResponse::release_myinforesponse() {
  auto temp = unsafe_arena_release_myinforesponse();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::chat::MyInfoResponse* ServerResponse::unsafe_arena_release_myinforesponse() {
  // @@protoc_insertion_point(field_release:chat.ServerResponse.myInfoResponse)
  _has_bits_[0] &= ~0x00000008u;
  ::chat::MyInfoResponse* temp = myinforesponse_;
  myinforesponse_ = nullptr;
  return temp;
}
inline ::chat::MyInfoResponse* ServerResponse::_internal_mutable_myinforesponse() {
  _has_bits_[0] |= 0x00000008u;
  if (myinforesponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat::MyInfoResponse>(GetArena());
    myinforesponse_ = p;
  }
  return myinforesponse_;
}
inline ::chat::MyInfoResponse* ServerResponse::mutable_myinforesponse() {
  // @@protoc_insertion_point(field_mutable:chat.ServerResponse.myInfoResponse)
  return _internal_mutable_myinforesponse();
}
inline void ServerResponse::set_allocated_myinforesponse(::chat::MyInfoResponse* myinforesponse) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete myinforesponse_;
  }
  if (myinforesponse) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(myinforesponse);
    if (message_arena != submessage_arena) {
      myinforesponse = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, myinforesponse, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  myinforesponse_ = myinforesponse;
  // @@protoc_insertion_point(field_set_allocated:chat.ServerResponse.myInfoResponse)
}

// optional .chat.ConnectedUserResponse connectedUserResponse = 6;
inline bool ServerResponse::_internal_has_connecteduserresponse() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || connecteduserresponse_ != nullptr);
  return value;
}
inline bool ServerResponse::has_connecteduserresponse() const {
  return _internal_has_connecteduserresponse();
}
inline void ServerResponse::clear_connecteduserresponse() {
  if (connecteduserresponse_ != nullptr) connecteduserresponse_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::chat::ConnectedUserResponse& ServerResponse::_internal_connecteduserresponse() const {
  const ::chat::ConnectedUserResponse* p = connecteduserresponse_;
  return p != nullptr ? *p : *reinterpret_cast<const ::chat::ConnectedUserResponse*>(
      &::chat::_ConnectedUserResponse_default_instance_);
}
inline const ::chat::ConnectedUserResponse& ServerResponse::connecteduserresponse() const {
  // @@protoc_insertion_point(field_get:chat.ServerResponse.connectedUserResponse)
  return _internal_connecteduserresponse();
}
inline void ServerResponse::unsafe_arena_set_allocated_connecteduserresponse(
    ::chat::ConnectedUserResponse* connecteduserresponse) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(connecteduserresponse_);
  }
  connecteduserresponse_ = connecteduserresponse;
  if (connecteduserresponse) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.ServerResponse.connectedUserResponse)
}
inline ::chat::ConnectedUserResponse* ServerResponse::release_connecteduserresponse() {
  auto temp = unsafe_arena_release_connecteduserresponse();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::chat::ConnectedUserResponse* ServerResponse::unsafe_arena_release_connecteduserresponse() {
  // @@protoc_insertion_point(field_release:chat.ServerResponse.connectedUserResponse)
  _has_bits_[0] &= ~0x00000010u;
  ::chat::ConnectedUserResponse* temp = connecteduserresponse_;
  connecteduserresponse_ = nullptr;
  return temp;
}
inline ::chat::ConnectedUserResponse* ServerResponse::_internal_mutable_connecteduserresponse() {
  _has_bits_[0] |= 0x00000010u;
  if (connecteduserresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat::ConnectedUserResponse>(GetArena());
    connecteduserresponse_ = p;
  }
  return connecteduserresponse_;
}
inline ::chat::ConnectedUserResponse* ServerResponse::mutable_connecteduserresponse() {
  // @@protoc_insertion_point(field_mutable:chat.ServerResponse.connectedUserResponse)
  return _internal_mutable_connecteduserresponse();
}
inline void ServerResponse::set_allocated_connecteduserresponse(::chat::ConnectedUserResponse* connecteduserresponse) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete connecteduserresponse_;
  }
  if (connecteduserresponse) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(connecteduserresponse);
    if (message_arena != submessage_arena) {
      connecteduserresponse = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, connecteduserresponse, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  connecteduserresponse_ = connecteduserresponse;
  // @@protoc_insertion_point(field_set_allocated:chat.ServerResponse.connectedUserResponse)
}

// optional .chat.ChangeStatusResponse changeStatusResponse = 7;
inline bool ServerResponse::_internal_has_changestatusresponse() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || changestatusresponse_ != nullptr);
  return value;
}
inline bool ServerResponse::has_changestatusresponse() const {
  return _internal_has_changestatusresponse();
}
inline void ServerResponse::clear_changestatusresponse() {
  if (changestatusresponse_ != nullptr) changestatusresponse_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::chat::ChangeStatusResponse& ServerResponse::_internal_changestatusresponse() const {
  const ::chat::ChangeStatusResponse* p = changestatusresponse_;
  return p != nullptr ? *p : *reinterpret_cast<const ::chat::ChangeStatusResponse*>(
      &::chat::_ChangeStatusResponse_default_instance_);
}
inline const ::chat::ChangeStatusResponse& ServerResponse::changestatusresponse() const {
  // @@protoc_insertion_point(field_get:chat.ServerResponse.changeStatusResponse)
  return _internal_changestatusresponse();
}
inline void ServerResponse::unsafe_arena_set_allocated_changestatusresponse(
    ::chat::ChangeStatusResponse* changestatusresponse) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(changestatusresponse_);
  }
  changestatusresponse_ = changestatusresponse;
  if (changestatusresponse) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.ServerResponse.changeStatusResponse)
}
inline ::chat::ChangeStatusResponse* ServerResponse::release_changestatusresponse() {
  auto temp = unsafe_arena_release_changestatusresponse();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::chat::ChangeStatusResponse* ServerResponse::unsafe_arena_release_changestatusresponse() {
  // @@protoc_insertion_point(field_release:chat.ServerResponse.changeStatusResponse)
  _has_bits_[0] &= ~0x00000020u;
  ::chat::ChangeStatusResponse* temp = changestatusresponse_;
  changestatusresponse_ = nullptr;
  return temp;
}
inline ::chat::ChangeStatusResponse* ServerResponse::_internal_mutable_changestatusresponse() {
  _has_bits_[0] |= 0x00000020u;
  if (changestatusresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat::ChangeStatusResponse>(GetArena());
    changestatusresponse_ = p;
  }
  return changestatusresponse_;
}
inline ::chat::ChangeStatusResponse* ServerResponse::mutable_changestatusresponse() {
  // @@protoc_insertion_point(field_mutable:chat.ServerResponse.changeStatusResponse)
  return _internal_mutable_changestatusresponse();
}
inline void ServerResponse::set_allocated_changestatusresponse(::chat::ChangeStatusResponse* changestatusresponse) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete changestatusresponse_;
  }
  if (changestatusresponse) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(changestatusresponse);
    if (message_arena != submessage_arena) {
      changestatusresponse = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, changestatusresponse, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  changestatusresponse_ = changestatusresponse;
  // @@protoc_insertion_point(field_set_allocated:chat.ServerResponse.changeStatusResponse)
}

// optional .chat.BroadcastResponse broadcastResponse = 8;
inline bool ServerResponse::_internal_has_broadcastresponse() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || broadcastresponse_ != nullptr);
  return value;
}
inline bool ServerResponse::has_broadcastresponse() const {
  return _internal_has_broadcastresponse();
}
inline void ServerResponse::clear_broadcastresponse() {
  if (broadcastresponse_ != nullptr) broadcastresponse_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::chat::BroadcastResponse& ServerResponse::_internal_broadcastresponse() const {
  const ::chat::BroadcastResponse* p = broadcastresponse_;
  return p != nullptr ? *p : *reinterpret_cast<const ::chat::BroadcastResponse*>(
      &::chat::_BroadcastResponse_default_instance_);
}
inline const ::chat::BroadcastResponse& ServerResponse::broadcastresponse() const {
  // @@protoc_insertion_point(field_get:chat.ServerResponse.broadcastResponse)
  return _internal_broadcastresponse();
}
inline void ServerResponse::unsafe_arena_set_allocated_broadcastresponse(
    ::chat::BroadcastResponse* broadcastresponse) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(broadcastresponse_);
  }
  broadcastresponse_ = broadcastresponse;
  if (broadcastresponse) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.ServerResponse.broadcastResponse)
}
inline ::chat::BroadcastResponse* ServerResponse::release_broadcastresponse() {
  auto temp = unsafe_arena_release_broadcastresponse();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::chat::BroadcastResponse* ServerResponse::unsafe_arena_release_broadcastresponse() {
  // @@protoc_insertion_point(field_release:chat.ServerResponse.broadcastResponse)
  _has_bits_[0] &= ~0x00000040u;
  ::chat::BroadcastResponse* temp = broadcastresponse_;
  broadcastresponse_ = nullptr;
  return temp;
}
inline ::chat::BroadcastResponse* ServerResponse::_internal_mutable_broadcastresponse() {
  _has_bits_[0] |= 0x00000040u;
  if (broadcastresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat::BroadcastResponse>(GetArena());
    broadcastresponse_ = p;
  }
  return broadcastresponse_;
}
inline ::chat::BroadcastResponse* ServerResponse::mutable_broadcastresponse() {
  // @@protoc_insertion_point(field_mutable:chat.ServerResponse.broadcastResponse)
  return _internal_mutable_broadcastresponse();
}
inline void ServerResponse::set_allocated_broadcastresponse(::chat::BroadcastResponse* broadcastresponse) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete broadcastresponse_;
  }
  if (broadcastresponse) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(broadcastresponse);
    if (message_arena != submessage_arena) {
      broadcastresponse = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, broadcastresponse, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  broadcastresponse_ = broadcastresponse;
  // @@protoc_insertion_point(field_set_allocated:chat.ServerResponse.broadcastResponse)
}

// optional .chat.DirectMessageResponse directMessageResponse = 9;
inline bool ServerResponse::_internal_has_directmessageresponse() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || directmessageresponse_ != nullptr);
  return value;
}
inline bool ServerResponse::has_directmessageresponse() const {
  return _internal_has_directmessageresponse();
}
inline void ServerResponse::clear_directmessageresponse() {
  if (directmessageresponse_ != nullptr) directmessageresponse_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::chat::DirectMessageResponse& ServerResponse::_internal_directmessageresponse() const {
  const ::chat::DirectMessageResponse* p = directmessageresponse_;
  return p != nullptr ? *p : *reinterpret_cast<const ::chat::DirectMessageResponse*>(
      &::chat::_DirectMessageResponse_default_instance_);
}
inline const ::chat::DirectMessageResponse& ServerResponse::directmessageresponse() const {
  // @@protoc_insertion_point(field_get:chat.ServerResponse.directMessageResponse)
  return _internal_directmessageresponse();
}
inline void ServerResponse::unsafe_arena_set_allocated_directmessageresponse(
    ::chat::DirectMessageResponse* directmessageresponse) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(directmessageresponse_);
  }
  directmessageresponse_ = directmessageresponse;
  if (directmessageresponse) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat.ServerResponse.directMessageResponse)
}
inline ::chat::DirectMessageResponse* ServerResponse::release_directmessageresponse() {
  auto temp = unsafe_arena_release_directmessageresponse();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::chat::DirectMessageResponse* ServerResponse::unsafe_arena_release_directmessageresponse() {
  // @@protoc_insertion_point(field_release:chat.ServerResponse.directMessageResponse)
  _has_bits_[0] &= ~0x00000080u;
  ::chat::DirectMessageResponse* temp = directmessageresponse_;
  directmessageresponse_ = nullptr;
  return temp;
}
inline ::chat::DirectMessageResponse* ServerResponse::_internal_mutable_directmessageresponse() {
  _has_bits_[0] |= 0x00000080u;
  if (directmessageresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat::DirectMessageResponse>(GetArena());
    directmessageresponse_ = p;
  }
  return directmessageresponse_;
}
inline ::chat::DirectMessageResponse* ServerResponse::mutable_directmessageresponse() {
  // @@protoc_insertion_point(field_mutable:chat.ServerResponse.directMessageResponse)
  return _internal_mutable_directmessageresponse();
}
inline void ServerResponse::set_allocated_directmessageresponse(::chat::DirectMessageResponse* directmessageresponse) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete directmessageresponse_;
  }
  if (directmessageresponse) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(directmessageresponse);
    if (message_arena != submessage_arena) {
      directmessageresponse = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, directmessageresponse, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  directmessageresponse_ = directmessageresponse;
  // @@protoc_insertion_point(field_set_allocated:chat.ServerResponse.directMessageResponse)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace chat

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_mensaje_2eproto
